// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: analytics.sql

package analyticsdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const agingAP = `-- name: AgingAP :many
SELECT a.bucket, a.amount::double precision AS amount, a.as_of
FROM mv_ap_aging a
WHERE a.as_of = $1
  AND a.company_id = $2
  AND ($3::bigint IS NULL OR a.branch_id = $3::bigint)
ORDER BY a.bucket
`

type AgingAPParams struct {
	AsOf      interface{} `json:"as_of"`
	CompanyID int64       `json:"company_id"`
	BranchID  pgtype.Int8 `json:"branch_id"`
}

type AgingAPRow struct {
	Bucket string      `json:"bucket"`
	Amount float64     `json:"amount"`
	AsOf   interface{} `json:"as_of"`
}

func (q *Queries) AgingAP(ctx context.Context, arg AgingAPParams) ([]AgingAPRow, error) {
	rows, err := q.db.Query(ctx, agingAP, arg.AsOf, arg.CompanyID, arg.BranchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AgingAPRow
	for rows.Next() {
		var i AgingAPRow
		if err := rows.Scan(&i.Bucket, &i.Amount, &i.AsOf); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const agingAR = `-- name: AgingAR :many
SELECT a.bucket, a.amount::double precision AS amount, a.as_of
FROM mv_ar_aging a
WHERE a.as_of = $1
  AND a.company_id = $2
  AND ($3::bigint IS NULL OR a.branch_id = $3::bigint)
ORDER BY a.bucket
`

type AgingARParams struct {
	AsOf      interface{} `json:"as_of"`
	CompanyID int64       `json:"company_id"`
	BranchID  pgtype.Int8 `json:"branch_id"`
}

type AgingARRow struct {
	Bucket string      `json:"bucket"`
	Amount float64     `json:"amount"`
	AsOf   interface{} `json:"as_of"`
}

func (q *Queries) AgingAR(ctx context.Context, arg AgingARParams) ([]AgingARRow, error) {
	rows, err := q.db.Query(ctx, agingAR, arg.AsOf, arg.CompanyID, arg.BranchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AgingARRow
	for rows.Next() {
		var i AgingARRow
		if err := rows.Scan(&i.Bucket, &i.Amount, &i.AsOf); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const kpiSummary = `-- name: KpiSummary :one
WITH pl AS (
  SELECT
    COALESCE(SUM(m.net)::double precision, 0) AS net_profit,
    COALESCE(SUM(m.revenue)::double precision, 0) AS revenue,
    COALESCE(SUM(m.opex)::double precision, 0) AS opex,
    COALESCE(SUM(m.cogs)::double precision, 0) AS cogs
  FROM mv_pl_monthly m
  WHERE m.period = $1
    AND m.company_id = $2
    AND ($3::bigint IS NULL OR m.branch_id = $3::bigint)
), cash AS (
  SELECT
    COALESCE(SUM(m.cash_in)::double precision, 0) AS cash_in,
    COALESCE(SUM(m.cash_out)::double precision, 0) AS cash_out
  FROM mv_cashflow_monthly m
  WHERE m.period = $1
    AND m.company_id = $2
    AND ($3::bigint IS NULL OR m.branch_id = $3::bigint)
), ar AS (
  SELECT COALESCE(SUM(a.amount)::double precision, 0) AS outstanding
  FROM mv_ar_aging a
  WHERE a.as_of = $4
    AND a.company_id = $2
    AND ($3::bigint IS NULL OR a.branch_id = $3::bigint)
), ap AS (
  SELECT COALESCE(SUM(a.amount)::double precision, 0) AS outstanding
  FROM mv_ap_aging a
  WHERE a.as_of = $4
    AND a.company_id = $2
    AND ($3::bigint IS NULL OR a.branch_id = $3::bigint)
)
SELECT
  pl.net_profit,
  pl.revenue,
  pl.opex,
  pl.cogs,
  cash.cash_in,
  cash.cash_out,
  ar.outstanding AS ar_outstanding,
  ap.outstanding AS ap_outstanding
FROM pl
CROSS JOIN cash
CROSS JOIN ar
CROSS JOIN ap
`

type KpiSummaryParams struct {
	Period    string      `json:"period"`
	CompanyID int64       `json:"company_id"`
	BranchID  pgtype.Int8 `json:"branch_id"`
	AsOf      interface{} `json:"as_of"`
}

type KpiSummaryRow struct {
	NetProfit     interface{} `json:"net_profit"`
	Revenue       interface{} `json:"revenue"`
	Opex          interface{} `json:"opex"`
	Cogs          interface{} `json:"cogs"`
	CashIn        interface{} `json:"cash_in"`
	CashOut       interface{} `json:"cash_out"`
	ArOutstanding interface{} `json:"ar_outstanding"`
	ApOutstanding interface{} `json:"ap_outstanding"`
}

func (q *Queries) KpiSummary(ctx context.Context, arg KpiSummaryParams) (KpiSummaryRow, error) {
	row := q.db.QueryRow(ctx, kpiSummary,
		arg.Period,
		arg.CompanyID,
		arg.BranchID,
		arg.AsOf,
	)
	var i KpiSummaryRow
	err := row.Scan(
		&i.NetProfit,
		&i.Revenue,
		&i.Opex,
		&i.Cogs,
		&i.CashIn,
		&i.CashOut,
		&i.ArOutstanding,
		&i.ApOutstanding,
	)
	return i, err
}

const monthlyCashflow = `-- name: MonthlyCashflow :many
SELECT m.period,
       m.company_id,
       m.branch_id,
       m.cash_in::double precision AS cash_in,
       m.cash_out::double precision AS cash_out
FROM mv_cashflow_monthly m
WHERE m.period BETWEEN $1 AND $2
  AND m.company_id = $3
  AND ($4::bigint IS NULL OR m.branch_id = $4::bigint)
ORDER BY m.period
`

type MonthlyCashflowParams struct {
	FromPeriod string      `json:"from_period"`
	ToPeriod   string      `json:"to_period"`
	CompanyID  int64       `json:"company_id"`
	BranchID   pgtype.Int8 `json:"branch_id"`
}

type MonthlyCashflowRow struct {
	Period    string  `json:"period"`
	CompanyID int64   `json:"company_id"`
	BranchID  int64   `json:"branch_id"`
	CashIn    float64 `json:"cash_in"`
	CashOut   float64 `json:"cash_out"`
}

func (q *Queries) MonthlyCashflow(ctx context.Context, arg MonthlyCashflowParams) ([]MonthlyCashflowRow, error) {
	rows, err := q.db.Query(ctx, monthlyCashflow,
		arg.FromPeriod,
		arg.ToPeriod,
		arg.CompanyID,
		arg.BranchID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MonthlyCashflowRow
	for rows.Next() {
		var i MonthlyCashflowRow
		if err := rows.Scan(
			&i.Period,
			&i.CompanyID,
			&i.BranchID,
			&i.CashIn,
			&i.CashOut,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const monthlyPL = `-- name: MonthlyPL :many
SELECT m.period,
       m.company_id,
       m.branch_id,
       m.revenue::double precision AS revenue,
       m.cogs::double precision AS cogs,
       m.opex::double precision AS opex,
       m.net::double precision AS net
FROM mv_pl_monthly m
WHERE m.period BETWEEN $1 AND $2
  AND m.company_id = $3
  AND ($4::bigint IS NULL OR m.branch_id = $4::bigint)
ORDER BY m.period
`

type MonthlyPLParams struct {
	FromPeriod string      `json:"from_period"`
	ToPeriod   string      `json:"to_period"`
	CompanyID  int64       `json:"company_id"`
	BranchID   pgtype.Int8 `json:"branch_id"`
}

type MonthlyPLRow struct {
	Period    string  `json:"period"`
	CompanyID int64   `json:"company_id"`
	BranchID  int64   `json:"branch_id"`
	Revenue   float64 `json:"revenue"`
	Cogs      float64 `json:"cogs"`
	Opex      float64 `json:"opex"`
	Net       float64 `json:"net"`
}

func (q *Queries) MonthlyPL(ctx context.Context, arg MonthlyPLParams) ([]MonthlyPLRow, error) {
	rows, err := q.db.Query(ctx, monthlyPL,
		arg.FromPeriod,
		arg.ToPeriod,
		arg.CompanyID,
		arg.BranchID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MonthlyPLRow
	for rows.Next() {
		var i MonthlyPLRow
		if err := rows.Scan(
			&i.Period,
			&i.CompanyID,
			&i.BranchID,
			&i.Revenue,
			&i.Cogs,
			&i.Opex,
			&i.Net,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
