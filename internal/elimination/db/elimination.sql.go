// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: elimination.sql

package eliminationdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countRuns = `-- name: CountRuns :one
SELECT COUNT(*) FROM elimination_runs
`

func (q *Queries) CountRuns(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countRuns)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getRule = `-- name: GetRule :one
SELECT id, group_id, name, source_company_id, target_company_id, account_src, account_tgt, match_criteria,
       is_active, created_by, created_at, updated_at
FROM elimination_rules WHERE id = $1
`

func (q *Queries) GetRule(ctx context.Context, id int64) (EliminationRule, error) {
	row := q.db.QueryRow(ctx, getRule, id)
	var i EliminationRule
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.Name,
		&i.SourceCompanyID,
		&i.TargetCompanyID,
		&i.AccountSrc,
		&i.AccountTgt,
		&i.MatchCriteria,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRun = `-- name: GetRun :one
SELECT er.id, er.period_id, er.rule_id, er.status, er.created_by, er.created_at, er.simulated_at, er.posted_at, er.journal_entry_id, er.summary,
       ru.id, ru.group_id, ru.name, ru.source_company_id, ru.target_company_id, ru.account_src, ru.account_tgt, ru.match_criteria,
       ru.is_active, ru.created_by, ru.created_at, ru.updated_at
FROM elimination_runs er
JOIN elimination_rules ru ON ru.id = er.rule_id
WHERE er.id = $1
`

type GetRunRow struct {
	ID              int64                `json:"id"`
	PeriodID        int64                `json:"period_id"`
	RuleID          int64                `json:"rule_id"`
	Status          EliminationRunStatus `json:"status"`
	CreatedBy       int64                `json:"created_by"`
	CreatedAt       pgtype.Timestamptz   `json:"created_at"`
	SimulatedAt     pgtype.Timestamptz   `json:"simulated_at"`
	PostedAt        pgtype.Timestamptz   `json:"posted_at"`
	JournalEntryID  pgtype.Int8          `json:"journal_entry_id"`
	Summary         []byte               `json:"summary"`
	ID_2            int64                `json:"id_2"`
	GroupID         pgtype.Int8          `json:"group_id"`
	Name            string               `json:"name"`
	SourceCompanyID int64                `json:"source_company_id"`
	TargetCompanyID int64                `json:"target_company_id"`
	AccountSrc      string               `json:"account_src"`
	AccountTgt      string               `json:"account_tgt"`
	MatchCriteria   []byte               `json:"match_criteria"`
	IsActive        bool                 `json:"is_active"`
	CreatedBy_2     int64                `json:"created_by_2"`
	CreatedAt_2     pgtype.Timestamptz   `json:"created_at_2"`
	UpdatedAt       pgtype.Timestamptz   `json:"updated_at"`
}

func (q *Queries) GetRun(ctx context.Context, id int64) (GetRunRow, error) {
	row := q.db.QueryRow(ctx, getRun, id)
	var i GetRunRow
	err := row.Scan(
		&i.ID,
		&i.PeriodID,
		&i.RuleID,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.SimulatedAt,
		&i.PostedAt,
		&i.JournalEntryID,
		&i.Summary,
		&i.ID_2,
		&i.GroupID,
		&i.Name,
		&i.SourceCompanyID,
		&i.TargetCompanyID,
		&i.AccountSrc,
		&i.AccountTgt,
		&i.MatchCriteria,
		&i.IsActive,
		&i.CreatedBy_2,
		&i.CreatedAt_2,
		&i.UpdatedAt,
	)
	return i, err
}

const insertRule = `-- name: InsertRule :one
INSERT INTO elimination_rules (group_id, name, source_company_id, target_company_id, account_src, account_tgt, match_criteria, created_by)
VALUES ($1,$2,$3,$4,$5,$6,$7,$8)
RETURNING id, group_id, name, source_company_id, target_company_id, account_src, account_tgt, match_criteria,
          is_active, created_by, created_at, updated_at
`

type InsertRuleParams struct {
	GroupID         pgtype.Int8 `json:"group_id"`
	Name            string      `json:"name"`
	SourceCompanyID int64       `json:"source_company_id"`
	TargetCompanyID int64       `json:"target_company_id"`
	AccountSrc      string      `json:"account_src"`
	AccountTgt      string      `json:"account_tgt"`
	MatchCriteria   []byte      `json:"match_criteria"`
	CreatedBy       int64       `json:"created_by"`
}

func (q *Queries) InsertRule(ctx context.Context, arg InsertRuleParams) (EliminationRule, error) {
	row := q.db.QueryRow(ctx, insertRule,
		arg.GroupID,
		arg.Name,
		arg.SourceCompanyID,
		arg.TargetCompanyID,
		arg.AccountSrc,
		arg.AccountTgt,
		arg.MatchCriteria,
		arg.CreatedBy,
	)
	var i EliminationRule
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.Name,
		&i.SourceCompanyID,
		&i.TargetCompanyID,
		&i.AccountSrc,
		&i.AccountTgt,
		&i.MatchCriteria,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertRun = `-- name: InsertRun :one
INSERT INTO elimination_runs (period_id, rule_id, status, created_by)
VALUES ($1,$2,'DRAFT',$3)
RETURNING id, period_id, rule_id, status, created_by, created_at, simulated_at, posted_at, journal_entry_id, summary
`

type InsertRunParams struct {
	PeriodID  int64 `json:"period_id"`
	RuleID    int64 `json:"rule_id"`
	CreatedBy int64 `json:"created_by"`
}

func (q *Queries) InsertRun(ctx context.Context, arg InsertRunParams) (EliminationRun, error) {
	row := q.db.QueryRow(ctx, insertRun, arg.PeriodID, arg.RuleID, arg.CreatedBy)
	var i EliminationRun
	err := row.Scan(
		&i.ID,
		&i.PeriodID,
		&i.RuleID,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.SimulatedAt,
		&i.PostedAt,
		&i.JournalEntryID,
		&i.Summary,
	)
	return i, err
}

const listRecentPeriods = `-- name: ListRecentPeriods :many
SELECT ap.id, ap.period_id, ap.name, ap.start_date, ap.end_date
FROM accounting_periods ap
ORDER BY ap.start_date DESC
LIMIT $1
`

type ListRecentPeriodsRow struct {
	ID        int64       `json:"id"`
	PeriodID  int64       `json:"period_id"`
	Name      string      `json:"name"`
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
}

func (q *Queries) ListRecentPeriods(ctx context.Context, limit int32) ([]ListRecentPeriodsRow, error) {
	rows, err := q.db.Query(ctx, listRecentPeriods, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRecentPeriodsRow
	for rows.Next() {
		var i ListRecentPeriodsRow
		if err := rows.Scan(
			&i.ID,
			&i.PeriodID,
			&i.Name,
			&i.StartDate,
			&i.EndDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRules = `-- name: ListRules :many
SELECT id, group_id, name, source_company_id, target_company_id, account_src, account_tgt, match_criteria,
       is_active, created_by, created_at, updated_at
FROM elimination_rules
ORDER BY created_at DESC
LIMIT $1
`

func (q *Queries) ListRules(ctx context.Context, limit int32) ([]EliminationRule, error) {
	rows, err := q.db.Query(ctx, listRules, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EliminationRule
	for rows.Next() {
		var i EliminationRule
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.Name,
			&i.SourceCompanyID,
			&i.TargetCompanyID,
			&i.AccountSrc,
			&i.AccountTgt,
			&i.MatchCriteria,
			&i.IsActive,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRuns = `-- name: ListRuns :many
SELECT er.id, er.period_id, er.rule_id, er.status, er.created_by, er.created_at, er.simulated_at, er.posted_at, er.journal_entry_id, er.summary,
       ru.id, ru.group_id, ru.name, ru.source_company_id, ru.target_company_id, ru.account_src, ru.account_tgt, ru.match_criteria,
       ru.is_active, ru.created_by, ru.created_at, ru.updated_at
FROM elimination_runs er
JOIN elimination_rules ru ON ru.id = er.rule_id
ORDER BY
  CASE WHEN $3::text = 'created_at' AND $4::text = 'asc' THEN er.created_at END ASC,
  CASE WHEN $3::text = 'created_at' AND $4::text = 'desc' THEN er.created_at END DESC,
  CASE WHEN $3::text = 'status' AND $4::text = 'asc' THEN er.status END ASC,
  CASE WHEN $3::text = 'status' AND $4::text = 'desc' THEN er.status END DESC,
  CASE WHEN $3::text = 'period_id' AND $4::text = 'asc' THEN er.period_id END ASC,
  CASE WHEN $3::text = 'period_id' AND $4::text = 'desc' THEN er.period_id END DESC,
  er.created_at DESC -- Default fallback
LIMIT $1 OFFSET $2
`

type ListRunsParams struct {
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
	SortBy  string `json:"sort_by"`
	SortDir string `json:"sort_dir"`
}

type ListRunsRow struct {
	ID              int64                `json:"id"`
	PeriodID        int64                `json:"period_id"`
	RuleID          int64                `json:"rule_id"`
	Status          EliminationRunStatus `json:"status"`
	CreatedBy       int64                `json:"created_by"`
	CreatedAt       pgtype.Timestamptz   `json:"created_at"`
	SimulatedAt     pgtype.Timestamptz   `json:"simulated_at"`
	PostedAt        pgtype.Timestamptz   `json:"posted_at"`
	JournalEntryID  pgtype.Int8          `json:"journal_entry_id"`
	Summary         []byte               `json:"summary"`
	ID_2            int64                `json:"id_2"`
	GroupID         pgtype.Int8          `json:"group_id"`
	Name            string               `json:"name"`
	SourceCompanyID int64                `json:"source_company_id"`
	TargetCompanyID int64                `json:"target_company_id"`
	AccountSrc      string               `json:"account_src"`
	AccountTgt      string               `json:"account_tgt"`
	MatchCriteria   []byte               `json:"match_criteria"`
	IsActive        bool                 `json:"is_active"`
	CreatedBy_2     int64                `json:"created_by_2"`
	CreatedAt_2     pgtype.Timestamptz   `json:"created_at_2"`
	UpdatedAt       pgtype.Timestamptz   `json:"updated_at"`
}

func (q *Queries) ListRuns(ctx context.Context, arg ListRunsParams) ([]ListRunsRow, error) {
	rows, err := q.db.Query(ctx, listRuns,
		arg.Limit,
		arg.Offset,
		arg.SortBy,
		arg.SortDir,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRunsRow
	for rows.Next() {
		var i ListRunsRow
		if err := rows.Scan(
			&i.ID,
			&i.PeriodID,
			&i.RuleID,
			&i.Status,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.SimulatedAt,
			&i.PostedAt,
			&i.JournalEntryID,
			&i.Summary,
			&i.ID_2,
			&i.GroupID,
			&i.Name,
			&i.SourceCompanyID,
			&i.TargetCompanyID,
			&i.AccountSrc,
			&i.AccountTgt,
			&i.MatchCriteria,
			&i.IsActive,
			&i.CreatedBy_2,
			&i.CreatedAt_2,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const loadAccountingPeriod = `-- name: LoadAccountingPeriod :one
SELECT ap.id, ap.period_id, ap.name, ap.start_date, ap.end_date
FROM accounting_periods ap
WHERE ap.id = $1
`

type LoadAccountingPeriodRow struct {
	ID        int64       `json:"id"`
	PeriodID  int64       `json:"period_id"`
	Name      string      `json:"name"`
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
}

func (q *Queries) LoadAccountingPeriod(ctx context.Context, id int64) (LoadAccountingPeriodRow, error) {
	row := q.db.QueryRow(ctx, loadAccountingPeriod, id)
	var i LoadAccountingPeriodRow
	err := row.Scan(
		&i.ID,
		&i.PeriodID,
		&i.Name,
		&i.StartDate,
		&i.EndDate,
	)
	return i, err
}

const lookupAccountID = `-- name: LookupAccountID :one
SELECT id FROM accounts WHERE code = $1
`

func (q *Queries) LookupAccountID(ctx context.Context, code string) (int64, error) {
	row := q.db.QueryRow(ctx, lookupAccountID, code)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const markRunPosted = `-- name: MarkRunPosted :exec
UPDATE elimination_runs
SET status = 'POSTED',
    posted_at = $2,
    journal_entry_id = $3
WHERE id = $1
`

type MarkRunPostedParams struct {
	ID             int64              `json:"id"`
	PostedAt       pgtype.Timestamptz `json:"posted_at"`
	JournalEntryID pgtype.Int8        `json:"journal_entry_id"`
}

func (q *Queries) MarkRunPosted(ctx context.Context, arg MarkRunPostedParams) error {
	_, err := q.db.Exec(ctx, markRunPosted, arg.ID, arg.PostedAt, arg.JournalEntryID)
	return err
}

const saveRunSimulation = `-- name: SaveRunSimulation :exec
UPDATE elimination_runs
SET status = $2,
    simulated_at = $3,
    summary = $4
WHERE id = $1
`

type SaveRunSimulationParams struct {
	ID          int64                `json:"id"`
	Status      EliminationRunStatus `json:"status"`
	SimulatedAt pgtype.Timestamptz   `json:"simulated_at"`
	Summary     []byte               `json:"summary"`
}

func (q *Queries) SaveRunSimulation(ctx context.Context, arg SaveRunSimulationParams) error {
	_, err := q.db.Exec(ctx, saveRunSimulation,
		arg.ID,
		arg.Status,
		arg.SimulatedAt,
		arg.Summary,
	)
	return err
}

const sumAccountBalance = `-- name: SumAccountBalance :one
SELECT COALESCE(SUM(jl.debit - jl.credit), 0)::float8
FROM journal_lines jl
JOIN journal_entries je ON je.id = jl.je_id AND je.status = 'POSTED'
JOIN accounts acc ON acc.id = jl.account_id
JOIN accounting_periods ap ON ap.id = $1
WHERE je.period_id = ap.period_id
  AND acc.code = $2
  AND COALESCE(jl.dim_company_id, 0) = $3
`

type SumAccountBalanceParams struct {
	ID           int64       `json:"id"`
	Code         string      `json:"code"`
	DimCompanyID pgtype.Int8 `json:"dim_company_id"`
}

func (q *Queries) SumAccountBalance(ctx context.Context, arg SumAccountBalanceParams) (float64, error) {
	row := q.db.QueryRow(ctx, sumAccountBalance, arg.ID, arg.Code, arg.DimCompanyID)
	var column_1 float64
	err := row.Scan(&column_1)
	return column_1, err
}
