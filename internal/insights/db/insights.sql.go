// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: insights.sql

package insightsdb

import (
	"context"
)

const compareMonthlyNetRevenue = `-- name: CompareMonthlyNetRevenue :many
SELECT period,
       COALESCE(SUM(net), 0)::double precision AS net,
       COALESCE(SUM(revenue), 0)::double precision AS revenue
FROM mv_pl_monthly
WHERE period BETWEEN $1 AND $2
  AND company_id = $3
  AND ($4 IS NULL OR branch_id = $4)
GROUP BY period
ORDER BY period
`

type CompareMonthlyNetRevenueParams struct {
	FromPeriod string      `json:"from_period"`
	ToPeriod   string      `json:"to_period"`
	CompanyID  int64       `json:"company_id"`
	BranchID   interface{} `json:"branch_id"`
}

type CompareMonthlyNetRevenueRow struct {
	Period  string  `json:"period"`
	Net     float64 `json:"net"`
	Revenue float64 `json:"revenue"`
}

func (q *Queries) CompareMonthlyNetRevenue(ctx context.Context, arg CompareMonthlyNetRevenueParams) ([]CompareMonthlyNetRevenueRow, error) {
	rows, err := q.db.Query(ctx, compareMonthlyNetRevenue,
		arg.FromPeriod,
		arg.ToPeriod,
		arg.CompanyID,
		arg.BranchID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CompareMonthlyNetRevenueRow
	for rows.Next() {
		var i CompareMonthlyNetRevenueRow
		if err := rows.Scan(&i.Period, &i.Net, &i.Revenue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const contributionByBranch = `-- name: ContributionByBranch :many
SELECT branch_id,
       COALESCE(SUM(net), 0)::double precision AS net,
       COALESCE(SUM(revenue), 0)::double precision AS revenue
FROM mv_pl_monthly
WHERE period = $1
  AND company_id = $2
GROUP BY branch_id
ORDER BY branch_id
`

type ContributionByBranchParams struct {
	Period    string `json:"period"`
	CompanyID int64  `json:"company_id"`
}

type ContributionByBranchRow struct {
	BranchID int64   `json:"branch_id"`
	Net      float64 `json:"net"`
	Revenue  float64 `json:"revenue"`
}

func (q *Queries) ContributionByBranch(ctx context.Context, arg ContributionByBranchParams) ([]ContributionByBranchRow, error) {
	rows, err := q.db.Query(ctx, contributionByBranch, arg.Period, arg.CompanyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ContributionByBranchRow
	for rows.Next() {
		var i ContributionByBranchRow
		if err := rows.Scan(&i.BranchID, &i.Net, &i.Revenue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
