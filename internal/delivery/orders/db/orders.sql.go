// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: orders.sql

package ordersdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkWarehouseExists = `-- name: CheckWarehouseExists :one
SELECT EXISTS(SELECT 1 FROM warehouses WHERE id = $1)
`

func (q *Queries) CheckWarehouseExists(ctx context.Context, id int64) (bool, error) {
	row := q.db.QueryRow(ctx, checkWarehouseExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createDeliveryOrder = `-- name: CreateDeliveryOrder :one
INSERT INTO delivery_orders (
    doc_number, company_id, sales_order_id, warehouse_id, customer_id,
    delivery_date, status, driver_name, vehicle_number, tracking_number,
    notes, created_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
)
RETURNING id
`

type CreateDeliveryOrderParams struct {
	DocNumber      string              `json:"doc_number"`
	CompanyID      int64               `json:"company_id"`
	SalesOrderID   int64               `json:"sales_order_id"`
	WarehouseID    int64               `json:"warehouse_id"`
	CustomerID     int64               `json:"customer_id"`
	DeliveryDate   pgtype.Date         `json:"delivery_date"`
	Status         DeliveryOrderStatus `json:"status"`
	DriverName     pgtype.Text         `json:"driver_name"`
	VehicleNumber  pgtype.Text         `json:"vehicle_number"`
	TrackingNumber pgtype.Text         `json:"tracking_number"`
	Notes          pgtype.Text         `json:"notes"`
	CreatedBy      int64               `json:"created_by"`
}

func (q *Queries) CreateDeliveryOrder(ctx context.Context, arg CreateDeliveryOrderParams) (int64, error) {
	row := q.db.QueryRow(ctx, createDeliveryOrder,
		arg.DocNumber,
		arg.CompanyID,
		arg.SalesOrderID,
		arg.WarehouseID,
		arg.CustomerID,
		arg.DeliveryDate,
		arg.Status,
		arg.DriverName,
		arg.VehicleNumber,
		arg.TrackingNumber,
		arg.Notes,
		arg.CreatedBy,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteLines = `-- name: DeleteLines :exec
DELETE FROM delivery_order_lines WHERE delivery_order_id = $1
`

func (q *Queries) DeleteLines(ctx context.Context, deliveryOrderID int64) error {
	_, err := q.db.Exec(ctx, deleteLines, deliveryOrderID)
	return err
}

const generateDocNumber = `-- name: GenerateDocNumber :one
SELECT generate_delivery_order_number($1, $2)
`

type GenerateDocNumberParams struct {
	PCompanyID int64       `json:"p_company_id"`
	PDate      pgtype.Date `json:"p_date"`
}

func (q *Queries) GenerateDocNumber(ctx context.Context, arg GenerateDocNumberParams) (string, error) {
	row := q.db.QueryRow(ctx, generateDocNumber, arg.PCompanyID, arg.PDate)
	var generate_delivery_order_number string
	err := row.Scan(&generate_delivery_order_number)
	return generate_delivery_order_number, err
}

const getByDocNumber = `-- name: GetByDocNumber :one
SELECT id, doc_number, company_id, sales_order_id, warehouse_id, customer_id,
       delivery_date, status, driver_name, vehicle_number, tracking_number,
       notes, created_by, confirmed_by, confirmed_at, delivered_at,
       created_at, updated_at
FROM delivery_orders
WHERE company_id = $1 AND doc_number = $2
`

type GetByDocNumberParams struct {
	CompanyID int64  `json:"company_id"`
	DocNumber string `json:"doc_number"`
}

func (q *Queries) GetByDocNumber(ctx context.Context, arg GetByDocNumberParams) (DeliveryOrder, error) {
	row := q.db.QueryRow(ctx, getByDocNumber, arg.CompanyID, arg.DocNumber)
	var i DeliveryOrder
	err := row.Scan(
		&i.ID,
		&i.DocNumber,
		&i.CompanyID,
		&i.SalesOrderID,
		&i.WarehouseID,
		&i.CustomerID,
		&i.DeliveryDate,
		&i.Status,
		&i.DriverName,
		&i.VehicleNumber,
		&i.TrackingNumber,
		&i.Notes,
		&i.CreatedBy,
		&i.ConfirmedBy,
		&i.ConfirmedAt,
		&i.DeliveredAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getByID = `-- name: GetByID :one
SELECT id, doc_number, company_id, sales_order_id, warehouse_id, customer_id,
       delivery_date, status, driver_name, vehicle_number, tracking_number,
       notes, created_by, confirmed_by, confirmed_at, delivered_at,
       created_at, updated_at
FROM delivery_orders
WHERE id = $1
`

func (q *Queries) GetByID(ctx context.Context, id int64) (DeliveryOrder, error) {
	row := q.db.QueryRow(ctx, getByID, id)
	var i DeliveryOrder
	err := row.Scan(
		&i.ID,
		&i.DocNumber,
		&i.CompanyID,
		&i.SalesOrderID,
		&i.WarehouseID,
		&i.CustomerID,
		&i.DeliveryDate,
		&i.Status,
		&i.DriverName,
		&i.VehicleNumber,
		&i.TrackingNumber,
		&i.Notes,
		&i.CreatedBy,
		&i.ConfirmedBy,
		&i.ConfirmedAt,
		&i.DeliveredAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDeliverableSOLines = `-- name: GetDeliverableSOLines :many
SELECT sol.id AS sales_order_line_id,
       sol.sales_order_id,
       sol.product_id,
       p.sku AS product_code,
       p.name AS product_name,
       sol.quantity,
       sol.quantity_delivered,
       (sol.quantity - sol.quantity_delivered)::NUMERIC AS remaining_quantity,
       sol.uom,
       sol.unit_price,
       sol.line_order
FROM sales_order_lines sol
INNER JOIN products p ON p.id = sol.product_id
WHERE sol.sales_order_id = $1
  AND sol.quantity > sol.quantity_delivered
ORDER BY sol.line_order, sol.id
`

type GetDeliverableSOLinesRow struct {
	SalesOrderLineID  int64          `json:"sales_order_line_id"`
	SalesOrderID      int64          `json:"sales_order_id"`
	ProductID         int64          `json:"product_id"`
	ProductCode       string         `json:"product_code"`
	ProductName       string         `json:"product_name"`
	Quantity          pgtype.Numeric `json:"quantity"`
	QuantityDelivered pgtype.Numeric `json:"quantity_delivered"`
	RemainingQuantity pgtype.Numeric `json:"remaining_quantity"`
	Uom               string         `json:"uom"`
	UnitPrice         pgtype.Numeric `json:"unit_price"`
	LineOrder         int32          `json:"line_order"`
}

func (q *Queries) GetDeliverableSOLines(ctx context.Context, salesOrderID int64) ([]GetDeliverableSOLinesRow, error) {
	rows, err := q.db.Query(ctx, getDeliverableSOLines, salesOrderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDeliverableSOLinesRow
	for rows.Next() {
		var i GetDeliverableSOLinesRow
		if err := rows.Scan(
			&i.SalesOrderLineID,
			&i.SalesOrderID,
			&i.ProductID,
			&i.ProductCode,
			&i.ProductName,
			&i.Quantity,
			&i.QuantityDelivered,
			&i.RemainingQuantity,
			&i.Uom,
			&i.UnitPrice,
			&i.LineOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLines = `-- name: GetLines :many
SELECT id, delivery_order_id, sales_order_line_id, product_id,
       quantity_to_deliver, quantity_delivered, uom, unit_price,
       notes, line_order, created_at, updated_at
FROM delivery_order_lines
WHERE delivery_order_id = $1
ORDER BY line_order, id
`

func (q *Queries) GetLines(ctx context.Context, deliveryOrderID int64) ([]DeliveryOrderLine, error) {
	rows, err := q.db.Query(ctx, getLines, deliveryOrderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeliveryOrderLine
	for rows.Next() {
		var i DeliveryOrderLine
		if err := rows.Scan(
			&i.ID,
			&i.DeliveryOrderID,
			&i.SalesOrderLineID,
			&i.ProductID,
			&i.QuantityToDeliver,
			&i.QuantityDelivered,
			&i.Uom,
			&i.UnitPrice,
			&i.Notes,
			&i.LineOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLinesWithDetails = `-- name: GetLinesWithDetails :many
SELECT dol.id, dol.delivery_order_id, dol.sales_order_line_id, dol.product_id,
       dol.quantity_to_deliver, dol.quantity_delivered, dol.uom, dol.unit_price,
       dol.notes, dol.line_order, dol.created_at, dol.updated_at,
       p.sku AS product_code,
       p.name AS product_name,
       sol.quantity AS so_line_quantity,
       sol.quantity_delivered AS so_line_delivered,
       (sol.quantity - sol.quantity_delivered)::NUMERIC AS remaining_to_deliver
FROM delivery_order_lines dol
INNER JOIN products p ON p.id = dol.product_id
INNER JOIN sales_order_lines sol ON sol.id = dol.sales_order_line_id
WHERE dol.delivery_order_id = $1
ORDER BY dol.line_order, dol.id
`

type GetLinesWithDetailsRow struct {
	ID                 int64              `json:"id"`
	DeliveryOrderID    int64              `json:"delivery_order_id"`
	SalesOrderLineID   int64              `json:"sales_order_line_id"`
	ProductID          int64              `json:"product_id"`
	QuantityToDeliver  pgtype.Numeric     `json:"quantity_to_deliver"`
	QuantityDelivered  pgtype.Numeric     `json:"quantity_delivered"`
	Uom                string             `json:"uom"`
	UnitPrice          pgtype.Numeric     `json:"unit_price"`
	Notes              pgtype.Text        `json:"notes"`
	LineOrder          int32              `json:"line_order"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	ProductCode        string             `json:"product_code"`
	ProductName        string             `json:"product_name"`
	SoLineQuantity     pgtype.Numeric     `json:"so_line_quantity"`
	SoLineDelivered    pgtype.Numeric     `json:"so_line_delivered"`
	RemainingToDeliver pgtype.Numeric     `json:"remaining_to_deliver"`
}

func (q *Queries) GetLinesWithDetails(ctx context.Context, deliveryOrderID int64) ([]GetLinesWithDetailsRow, error) {
	rows, err := q.db.Query(ctx, getLinesWithDetails, deliveryOrderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLinesWithDetailsRow
	for rows.Next() {
		var i GetLinesWithDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.DeliveryOrderID,
			&i.SalesOrderLineID,
			&i.ProductID,
			&i.QuantityToDeliver,
			&i.QuantityDelivered,
			&i.Uom,
			&i.UnitPrice,
			&i.Notes,
			&i.LineOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProductCode,
			&i.ProductName,
			&i.SoLineQuantity,
			&i.SoLineDelivered,
			&i.RemainingToDeliver,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSalesOrderDetails = `-- name: GetSalesOrderDetails :one
SELECT id, doc_number, company_id, customer_id, status
FROM sales_orders
WHERE id = $1
`

type GetSalesOrderDetailsRow struct {
	ID         int64            `json:"id"`
	DocNumber  string           `json:"doc_number"`
	CompanyID  int64            `json:"company_id"`
	CustomerID int64            `json:"customer_id"`
	Status     SalesOrderStatus `json:"status"`
}

func (q *Queries) GetSalesOrderDetails(ctx context.Context, id int64) (GetSalesOrderDetailsRow, error) {
	row := q.db.QueryRow(ctx, getSalesOrderDetails, id)
	var i GetSalesOrderDetailsRow
	err := row.Scan(
		&i.ID,
		&i.DocNumber,
		&i.CompanyID,
		&i.CustomerID,
		&i.Status,
	)
	return i, err
}

const getWithDetails = `-- name: GetWithDetails :one
SELECT dor.id, dor.doc_number, dor.company_id, dor.sales_order_id, dor.warehouse_id,
       dor.customer_id, dor.delivery_date, dor.status, dor.driver_name,
       dor.vehicle_number, dor.tracking_number, dor.notes, dor.created_by,
       dor.confirmed_by, dor.confirmed_at, dor.delivered_at,
       dor.created_at, dor.updated_at,
       so.doc_number AS sales_order_number,
       w.name AS warehouse_name,
       c.name AS customer_name,
       u_created.email AS created_by_name,
       u_confirmed.email AS confirmed_by_name,
       COUNT(dol.id) AS line_count,
       COALESCE(SUM(dol.quantity_to_deliver), 0)::NUMERIC AS total_quantity
FROM delivery_orders dor
INNER JOIN sales_orders so ON so.id = dor.sales_order_id
INNER JOIN warehouses w ON w.id = dor.warehouse_id
INNER JOIN customers c ON c.id = dor.customer_id
INNER JOIN users u_created ON u_created.id = dor.created_by
LEFT JOIN users u_confirmed ON u_confirmed.id = dor.confirmed_by
LEFT JOIN delivery_order_lines dol ON dol.delivery_order_id = dor.id
WHERE dor.id = $1
GROUP BY dor.id, dor.doc_number, dor.company_id, dor.sales_order_id, dor.warehouse_id,
            dor.customer_id, dor.delivery_date, dor.status, dor.driver_name,
            dor.vehicle_number, dor.tracking_number, dor.notes, dor.created_by,
            dor.confirmed_by, dor.confirmed_at, dor.delivered_at,
            dor.created_at, dor.updated_at, so.doc_number, w.name, c.name,
            u_created.email, u_confirmed.email
`

type GetWithDetailsRow struct {
	ID               int64               `json:"id"`
	DocNumber        string              `json:"doc_number"`
	CompanyID        int64               `json:"company_id"`
	SalesOrderID     int64               `json:"sales_order_id"`
	WarehouseID      int64               `json:"warehouse_id"`
	CustomerID       int64               `json:"customer_id"`
	DeliveryDate     pgtype.Date         `json:"delivery_date"`
	Status           DeliveryOrderStatus `json:"status"`
	DriverName       pgtype.Text         `json:"driver_name"`
	VehicleNumber    pgtype.Text         `json:"vehicle_number"`
	TrackingNumber   pgtype.Text         `json:"tracking_number"`
	Notes            pgtype.Text         `json:"notes"`
	CreatedBy        int64               `json:"created_by"`
	ConfirmedBy      pgtype.Int8         `json:"confirmed_by"`
	ConfirmedAt      pgtype.Timestamptz  `json:"confirmed_at"`
	DeliveredAt      pgtype.Timestamptz  `json:"delivered_at"`
	CreatedAt        pgtype.Timestamptz  `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz  `json:"updated_at"`
	SalesOrderNumber string              `json:"sales_order_number"`
	WarehouseName    string              `json:"warehouse_name"`
	CustomerName     string              `json:"customer_name"`
	CreatedByName    string              `json:"created_by_name"`
	ConfirmedByName  pgtype.Text         `json:"confirmed_by_name"`
	LineCount        int64               `json:"line_count"`
	TotalQuantity    pgtype.Numeric      `json:"total_quantity"`
}

func (q *Queries) GetWithDetails(ctx context.Context, id int64) (GetWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getWithDetails, id)
	var i GetWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.DocNumber,
		&i.CompanyID,
		&i.SalesOrderID,
		&i.WarehouseID,
		&i.CustomerID,
		&i.DeliveryDate,
		&i.Status,
		&i.DriverName,
		&i.VehicleNumber,
		&i.TrackingNumber,
		&i.Notes,
		&i.CreatedBy,
		&i.ConfirmedBy,
		&i.ConfirmedAt,
		&i.DeliveredAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SalesOrderNumber,
		&i.WarehouseName,
		&i.CustomerName,
		&i.CreatedByName,
		&i.ConfirmedByName,
		&i.LineCount,
		&i.TotalQuantity,
	)
	return i, err
}

const insertLine = `-- name: InsertLine :one
INSERT INTO delivery_order_lines (
    delivery_order_id, sales_order_line_id, product_id,
    quantity_to_deliver, quantity_delivered, uom, unit_price,
    notes, line_order
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id
`

type InsertLineParams struct {
	DeliveryOrderID   int64          `json:"delivery_order_id"`
	SalesOrderLineID  int64          `json:"sales_order_line_id"`
	ProductID         int64          `json:"product_id"`
	QuantityToDeliver pgtype.Numeric `json:"quantity_to_deliver"`
	QuantityDelivered pgtype.Numeric `json:"quantity_delivered"`
	Uom               string         `json:"uom"`
	UnitPrice         pgtype.Numeric `json:"unit_price"`
	Notes             pgtype.Text    `json:"notes"`
	LineOrder         int32          `json:"line_order"`
}

func (q *Queries) InsertLine(ctx context.Context, arg InsertLineParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertLine,
		arg.DeliveryOrderID,
		arg.SalesOrderLineID,
		arg.ProductID,
		arg.QuantityToDeliver,
		arg.QuantityDelivered,
		arg.Uom,
		arg.UnitPrice,
		arg.Notes,
		arg.LineOrder,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateLineQuantity = `-- name: UpdateLineQuantity :exec
UPDATE delivery_order_lines
SET quantity_delivered = $1, updated_at = $2
WHERE id = $3
`

type UpdateLineQuantityParams struct {
	QuantityDelivered pgtype.Numeric     `json:"quantity_delivered"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	ID                int64              `json:"id"`
}

func (q *Queries) UpdateLineQuantity(ctx context.Context, arg UpdateLineQuantityParams) error {
	_, err := q.db.Exec(ctx, updateLineQuantity, arg.QuantityDelivered, arg.UpdatedAt, arg.ID)
	return err
}

const updateStatus = `-- name: UpdateStatus :exec
UPDATE delivery_orders
SET status = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateStatusParams struct {
	ID     int64               `json:"id"`
	Status DeliveryOrderStatus `json:"status"`
}

func (q *Queries) UpdateStatus(ctx context.Context, arg UpdateStatusParams) error {
	_, err := q.db.Exec(ctx, updateStatus, arg.ID, arg.Status)
	return err
}

const updateStatusConfirmed = `-- name: UpdateStatusConfirmed :exec
UPDATE delivery_orders
SET status = $2, confirmed_by = $3, confirmed_at = NOW(), updated_at = NOW()
WHERE id = $1
`

type UpdateStatusConfirmedParams struct {
	ID          int64               `json:"id"`
	Status      DeliveryOrderStatus `json:"status"`
	ConfirmedBy pgtype.Int8         `json:"confirmed_by"`
}

func (q *Queries) UpdateStatusConfirmed(ctx context.Context, arg UpdateStatusConfirmedParams) error {
	_, err := q.db.Exec(ctx, updateStatusConfirmed, arg.ID, arg.Status, arg.ConfirmedBy)
	return err
}
