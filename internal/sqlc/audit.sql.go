// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: audit.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const auditTimelineAll = `-- name: AuditTimelineAll :many
SELECT a.occurred_at AS at,
       COALESCE(u.email, a.actor_id::text) AS actor,
       a.action,
       a.entity,
       a.entity_id::text AS entity_id,
       je.number AS journal_no,
       p.code AS period_code
FROM audit_logs a
LEFT JOIN users u ON u.id = a.actor_id
LEFT JOIN source_links sl
       ON sl.module = a.entity
      AND sl.ref_id::text = a.entity_id::text
LEFT JOIN journal_entries je
       ON (a.entity = 'journal_entries' AND je.id::text = a.entity_id::text)
       OR (sl.je_id = je.id)
LEFT JOIN periods p ON p.id = je.period_id
WHERE a.occurred_at BETWEEN $1 AND $2
  AND ($3::text IS NULL OR a.actor_id::text = $3::text)
  AND ($4::text IS NULL OR a.entity = $4::text)
  AND ($5::text IS NULL OR a.action = $5::text)
ORDER BY a.occurred_at DESC
`

type AuditTimelineAllParams struct {
	FromAt pgtype.Timestamptz `json:"from_at"`
	ToAt   pgtype.Timestamptz `json:"to_at"`
	Actor  pgtype.Text        `json:"actor"`
	Entity pgtype.Text        `json:"entity"`
	Action pgtype.Text        `json:"action"`
}

type AuditTimelineAllRow struct {
	At         pgtype.Timestamptz `json:"at"`
	Actor      string             `json:"actor"`
	Action     string             `json:"action"`
	Entity     string             `json:"entity"`
	EntityID   string             `json:"entity_id"`
	JournalNo  pgtype.Int8        `json:"journal_no"`
	PeriodCode pgtype.Text        `json:"period_code"`
}

func (q *Queries) AuditTimelineAll(ctx context.Context, arg AuditTimelineAllParams) ([]AuditTimelineAllRow, error) {
	rows, err := q.db.Query(ctx, auditTimelineAll,
		arg.FromAt,
		arg.ToAt,
		arg.Actor,
		arg.Entity,
		arg.Action,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuditTimelineAllRow
	for rows.Next() {
		var i AuditTimelineAllRow
		if err := rows.Scan(
			&i.At,
			&i.Actor,
			&i.Action,
			&i.Entity,
			&i.EntityID,
			&i.JournalNo,
			&i.PeriodCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const auditTimelineWindow = `-- name: AuditTimelineWindow :many
SELECT a.occurred_at AS at,
       COALESCE(u.email, a.actor_id::text) AS actor,
       a.action,
       a.entity,
       a.entity_id::text AS entity_id,
       je.number AS journal_no,
       p.code AS period_code
FROM audit_logs a
LEFT JOIN users u ON u.id = a.actor_id
LEFT JOIN source_links sl
       ON sl.module = a.entity
      AND sl.ref_id::text = a.entity_id::text
LEFT JOIN journal_entries je
       ON (a.entity = 'journal_entries' AND je.id::text = a.entity_id::text)
       OR (sl.je_id = je.id)
LEFT JOIN periods p ON p.id = je.period_id
WHERE a.occurred_at BETWEEN $1 AND $2
  AND ($3::text IS NULL OR a.actor_id::text = $3::text)
  AND ($4::text IS NULL OR a.entity = $4::text)
  AND ($5::text IS NULL OR a.action = $5::text)
ORDER BY a.occurred_at DESC
LIMIT $7 OFFSET $6
`

type AuditTimelineWindowParams struct {
	FromAt     pgtype.Timestamptz `json:"from_at"`
	ToAt       pgtype.Timestamptz `json:"to_at"`
	Actor      pgtype.Text        `json:"actor"`
	Entity     pgtype.Text        `json:"entity"`
	Action     pgtype.Text        `json:"action"`
	OffsetRows int32              `json:"offset_rows"`
	LimitRows  int32              `json:"limit_rows"`
}

type AuditTimelineWindowRow struct {
	At         pgtype.Timestamptz `json:"at"`
	Actor      string             `json:"actor"`
	Action     string             `json:"action"`
	Entity     string             `json:"entity"`
	EntityID   string             `json:"entity_id"`
	JournalNo  pgtype.Int8        `json:"journal_no"`
	PeriodCode pgtype.Text        `json:"period_code"`
}

func (q *Queries) AuditTimelineWindow(ctx context.Context, arg AuditTimelineWindowParams) ([]AuditTimelineWindowRow, error) {
	rows, err := q.db.Query(ctx, auditTimelineWindow,
		arg.FromAt,
		arg.ToAt,
		arg.Actor,
		arg.Entity,
		arg.Action,
		arg.OffsetRows,
		arg.LimitRows,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuditTimelineWindowRow
	for rows.Next() {
		var i AuditTimelineWindowRow
		if err := rows.Scan(
			&i.At,
			&i.Actor,
			&i.Action,
			&i.Entity,
			&i.EntityID,
			&i.JournalNo,
			&i.PeriodCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
