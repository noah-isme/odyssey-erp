// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: procurement.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAPInvoice = `-- name: CreateAPInvoice :one

INSERT INTO ap_invoices (number, supplier_id, grn_id, currency, total, status, issued_at, due_at, created_at)
VALUES ($1, $2, $3, $4, $5, $6, CURRENT_DATE, $7, NOW())
RETURNING id
`

type CreateAPInvoiceParams struct {
	Number     string         `json:"number"`
	SupplierID int64          `json:"supplier_id"`
	GrnID      pgtype.Int8    `json:"grn_id"`
	Currency   string         `json:"currency"`
	Total      pgtype.Numeric `json:"total"`
	Status     string         `json:"status"`
	DueAt      pgtype.Date    `json:"due_at"`
}

// =============================================================================
// AP INVOICES
// =============================================================================
func (q *Queries) CreateAPInvoice(ctx context.Context, arg CreateAPInvoiceParams) (int64, error) {
	row := q.db.QueryRow(ctx, createAPInvoice,
		arg.Number,
		arg.SupplierID,
		arg.GrnID,
		arg.Currency,
		arg.Total,
		arg.Status,
		arg.DueAt,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createGRN = `-- name: CreateGRN :one

INSERT INTO grns (number, po_id, supplier_id, warehouse_id, status, received_at, note, created_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())
RETURNING id
`

type CreateGRNParams struct {
	Number      string             `json:"number"`
	PoID        pgtype.Int8        `json:"po_id"`
	SupplierID  int64              `json:"supplier_id"`
	WarehouseID int64              `json:"warehouse_id"`
	Status      string             `json:"status"`
	ReceivedAt  pgtype.Timestamptz `json:"received_at"`
	Note        string             `json:"note"`
}

// =============================================================================
// GOODS RECEIPTS (GRN)
// =============================================================================
func (q *Queries) CreateGRN(ctx context.Context, arg CreateGRNParams) (int64, error) {
	row := q.db.QueryRow(ctx, createGRN,
		arg.Number,
		arg.PoID,
		arg.SupplierID,
		arg.WarehouseID,
		arg.Status,
		arg.ReceivedAt,
		arg.Note,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createPO = `-- name: CreatePO :one

INSERT INTO pos (number, supplier_id, status, currency, expected_date, note, created_at)
VALUES ($1, $2, $3, $4, $5, $6, NOW())
RETURNING id
`

type CreatePOParams struct {
	Number       string      `json:"number"`
	SupplierID   int64       `json:"supplier_id"`
	Status       string      `json:"status"`
	Currency     string      `json:"currency"`
	ExpectedDate pgtype.Date `json:"expected_date"`
	Note         string      `json:"note"`
}

// =============================================================================
// PURCHASE ORDERS (PO)
// =============================================================================
func (q *Queries) CreatePO(ctx context.Context, arg CreatePOParams) (int64, error) {
	row := q.db.QueryRow(ctx, createPO,
		arg.Number,
		arg.SupplierID,
		arg.Status,
		arg.Currency,
		arg.ExpectedDate,
		arg.Note,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createPR = `-- name: CreatePR :one

INSERT INTO prs (number, supplier_id, request_by, status, note, created_at)
VALUES ($1, $2, $3, $4, $5, NOW())
RETURNING id
`

type CreatePRParams struct {
	Number     string      `json:"number"`
	SupplierID pgtype.Int8 `json:"supplier_id"`
	RequestBy  int64       `json:"request_by"`
	Status     string      `json:"status"`
	Note       string      `json:"note"`
}

// =============================================================================
// PURCHASE REQUESTS (PR)
// =============================================================================
func (q *Queries) CreatePR(ctx context.Context, arg CreatePRParams) (int64, error) {
	row := q.db.QueryRow(ctx, createPR,
		arg.Number,
		arg.SupplierID,
		arg.RequestBy,
		arg.Status,
		arg.Note,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createPayment = `-- name: CreatePayment :one
INSERT INTO ap_payments (number, ap_invoice_id, amount, paid_at, method, note)
VALUES ($1, $2, $3, CURRENT_DATE, 'TRANSFER', '')
RETURNING id
`

type CreatePaymentParams struct {
	Number      string         `json:"number"`
	ApInvoiceID int64          `json:"ap_invoice_id"`
	Amount      pgtype.Numeric `json:"amount"`
}

func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (int64, error) {
	row := q.db.QueryRow(ctx, createPayment, arg.Number, arg.ApInvoiceID, arg.Amount)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getAPInvoice = `-- name: GetAPInvoice :one
SELECT id, number, supplier_id, grn_id, currency, total, status, due_at
FROM ap_invoices WHERE id = $1
`

type GetAPInvoiceRow struct {
	ID         int64          `json:"id"`
	Number     string         `json:"number"`
	SupplierID int64          `json:"supplier_id"`
	GrnID      pgtype.Int8    `json:"grn_id"`
	Currency   string         `json:"currency"`
	Total      pgtype.Numeric `json:"total"`
	Status     string         `json:"status"`
	DueAt      pgtype.Date    `json:"due_at"`
}

func (q *Queries) GetAPInvoice(ctx context.Context, id int64) (GetAPInvoiceRow, error) {
	row := q.db.QueryRow(ctx, getAPInvoice, id)
	var i GetAPInvoiceRow
	err := row.Scan(
		&i.ID,
		&i.Number,
		&i.SupplierID,
		&i.GrnID,
		&i.Currency,
		&i.Total,
		&i.Status,
		&i.DueAt,
	)
	return i, err
}

const getGRN = `-- name: GetGRN :one
SELECT id, number, po_id, supplier_id, warehouse_id, status, received_at, note
FROM grns WHERE id = $1
`

type GetGRNRow struct {
	ID          int64              `json:"id"`
	Number      string             `json:"number"`
	PoID        pgtype.Int8        `json:"po_id"`
	SupplierID  int64              `json:"supplier_id"`
	WarehouseID int64              `json:"warehouse_id"`
	Status      string             `json:"status"`
	ReceivedAt  pgtype.Timestamptz `json:"received_at"`
	Note        string             `json:"note"`
}

func (q *Queries) GetGRN(ctx context.Context, id int64) (GetGRNRow, error) {
	row := q.db.QueryRow(ctx, getGRN, id)
	var i GetGRNRow
	err := row.Scan(
		&i.ID,
		&i.Number,
		&i.PoID,
		&i.SupplierID,
		&i.WarehouseID,
		&i.Status,
		&i.ReceivedAt,
		&i.Note,
	)
	return i, err
}

const getGRNLines = `-- name: GetGRNLines :many
SELECT id, grn_id, product_id, qty, unit_cost
FROM grn_lines WHERE grn_id = $1 ORDER BY id
`

func (q *Queries) GetGRNLines(ctx context.Context, grnID int64) ([]GrnLine, error) {
	rows, err := q.db.Query(ctx, getGRNLines, grnID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GrnLine
	for rows.Next() {
		var i GrnLine
		if err := rows.Scan(
			&i.ID,
			&i.GrnID,
			&i.ProductID,
			&i.Qty,
			&i.UnitCost,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPO = `-- name: GetPO :one
SELECT id, number, supplier_id, status, currency, expected_date, note
FROM pos WHERE id = $1
`

type GetPORow struct {
	ID           int64       `json:"id"`
	Number       string      `json:"number"`
	SupplierID   int64       `json:"supplier_id"`
	Status       string      `json:"status"`
	Currency     string      `json:"currency"`
	ExpectedDate pgtype.Date `json:"expected_date"`
	Note         string      `json:"note"`
}

func (q *Queries) GetPO(ctx context.Context, id int64) (GetPORow, error) {
	row := q.db.QueryRow(ctx, getPO, id)
	var i GetPORow
	err := row.Scan(
		&i.ID,
		&i.Number,
		&i.SupplierID,
		&i.Status,
		&i.Currency,
		&i.ExpectedDate,
		&i.Note,
	)
	return i, err
}

const getPOLines = `-- name: GetPOLines :many
SELECT id, po_id, product_id, qty, price, tax_id, note
FROM po_lines WHERE po_id = $1 ORDER BY id
`

func (q *Queries) GetPOLines(ctx context.Context, poID int64) ([]PoLine, error) {
	rows, err := q.db.Query(ctx, getPOLines, poID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PoLine
	for rows.Next() {
		var i PoLine
		if err := rows.Scan(
			&i.ID,
			&i.PoID,
			&i.ProductID,
			&i.Qty,
			&i.Price,
			&i.TaxID,
			&i.Note,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPR = `-- name: GetPR :one
SELECT id, number, supplier_id, request_by, status, note
FROM prs WHERE id = $1
`

type GetPRRow struct {
	ID         int64       `json:"id"`
	Number     string      `json:"number"`
	SupplierID pgtype.Int8 `json:"supplier_id"`
	RequestBy  int64       `json:"request_by"`
	Status     string      `json:"status"`
	Note       string      `json:"note"`
}

func (q *Queries) GetPR(ctx context.Context, id int64) (GetPRRow, error) {
	row := q.db.QueryRow(ctx, getPR, id)
	var i GetPRRow
	err := row.Scan(
		&i.ID,
		&i.Number,
		&i.SupplierID,
		&i.RequestBy,
		&i.Status,
		&i.Note,
	)
	return i, err
}

const getPRLines = `-- name: GetPRLines :many
SELECT id, pr_id, product_id, qty, note
FROM pr_lines WHERE pr_id = $1 ORDER BY id
`

func (q *Queries) GetPRLines(ctx context.Context, prID int64) ([]PrLine, error) {
	rows, err := q.db.Query(ctx, getPRLines, prID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PrLine
	for rows.Next() {
		var i PrLine
		if err := rows.Scan(
			&i.ID,
			&i.PrID,
			&i.ProductID,
			&i.Qty,
			&i.Note,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertGRNLine = `-- name: InsertGRNLine :exec
INSERT INTO grn_lines (grn_id, product_id, qty, unit_cost)
VALUES ($1, $2, $3, $4)
`

type InsertGRNLineParams struct {
	GrnID     int64          `json:"grn_id"`
	ProductID int64          `json:"product_id"`
	Qty       pgtype.Numeric `json:"qty"`
	UnitCost  pgtype.Numeric `json:"unit_cost"`
}

func (q *Queries) InsertGRNLine(ctx context.Context, arg InsertGRNLineParams) error {
	_, err := q.db.Exec(ctx, insertGRNLine,
		arg.GrnID,
		arg.ProductID,
		arg.Qty,
		arg.UnitCost,
	)
	return err
}

const insertPOLine = `-- name: InsertPOLine :exec
INSERT INTO po_lines (po_id, product_id, qty, price, tax_id, note)
VALUES ($1, $2, $3, $4, $5, $6)
`

type InsertPOLineParams struct {
	PoID      int64          `json:"po_id"`
	ProductID int64          `json:"product_id"`
	Qty       pgtype.Numeric `json:"qty"`
	Price     pgtype.Numeric `json:"price"`
	TaxID     pgtype.Int8    `json:"tax_id"`
	Note      string         `json:"note"`
}

func (q *Queries) InsertPOLine(ctx context.Context, arg InsertPOLineParams) error {
	_, err := q.db.Exec(ctx, insertPOLine,
		arg.PoID,
		arg.ProductID,
		arg.Qty,
		arg.Price,
		arg.TaxID,
		arg.Note,
	)
	return err
}

const insertPRLine = `-- name: InsertPRLine :exec
INSERT INTO pr_lines (pr_id, product_id, qty, note)
VALUES ($1, $2, $3, $4)
`

type InsertPRLineParams struct {
	PrID      int64          `json:"pr_id"`
	ProductID int64          `json:"product_id"`
	Qty       pgtype.Numeric `json:"qty"`
	Note      string         `json:"note"`
}

func (q *Queries) InsertPRLine(ctx context.Context, arg InsertPRLineParams) error {
	_, err := q.db.Exec(ctx, insertPRLine,
		arg.PrID,
		arg.ProductID,
		arg.Qty,
		arg.Note,
	)
	return err
}

const listAPOutstanding = `-- name: ListAPOutstanding :many
SELECT id, number, supplier_id, grn_id, currency, total, status, due_at
FROM ap_invoices 
WHERE status IN ('POSTED','PAID') 
ORDER BY due_at
`

type ListAPOutstandingRow struct {
	ID         int64          `json:"id"`
	Number     string         `json:"number"`
	SupplierID int64          `json:"supplier_id"`
	GrnID      pgtype.Int8    `json:"grn_id"`
	Currency   string         `json:"currency"`
	Total      pgtype.Numeric `json:"total"`
	Status     string         `json:"status"`
	DueAt      pgtype.Date    `json:"due_at"`
}

func (q *Queries) ListAPOutstanding(ctx context.Context) ([]ListAPOutstandingRow, error) {
	rows, err := q.db.Query(ctx, listAPOutstanding)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAPOutstandingRow
	for rows.Next() {
		var i ListAPOutstandingRow
		if err := rows.Scan(
			&i.ID,
			&i.Number,
			&i.SupplierID,
			&i.GrnID,
			&i.Currency,
			&i.Total,
			&i.Status,
			&i.DueAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setPOApproval = `-- name: SetPOApproval :exec
UPDATE pos SET approved_by = $1, approved_at = $2 WHERE id = $3
`

type SetPOApprovalParams struct {
	ApprovedBy pgtype.Int8        `json:"approved_by"`
	ApprovedAt pgtype.Timestamptz `json:"approved_at"`
	ID         int64              `json:"id"`
}

func (q *Queries) SetPOApproval(ctx context.Context, arg SetPOApprovalParams) error {
	_, err := q.db.Exec(ctx, setPOApproval, arg.ApprovedBy, arg.ApprovedAt, arg.ID)
	return err
}

const updateAPStatus = `-- name: UpdateAPStatus :exec
UPDATE ap_invoices SET status = $1 WHERE id = $2
`

type UpdateAPStatusParams struct {
	Status string `json:"status"`
	ID     int64  `json:"id"`
}

func (q *Queries) UpdateAPStatus(ctx context.Context, arg UpdateAPStatusParams) error {
	_, err := q.db.Exec(ctx, updateAPStatus, arg.Status, arg.ID)
	return err
}

const updateGRNStatus = `-- name: UpdateGRNStatus :exec
UPDATE grns SET status = $1 WHERE id = $2
`

type UpdateGRNStatusParams struct {
	Status string `json:"status"`
	ID     int64  `json:"id"`
}

func (q *Queries) UpdateGRNStatus(ctx context.Context, arg UpdateGRNStatusParams) error {
	_, err := q.db.Exec(ctx, updateGRNStatus, arg.Status, arg.ID)
	return err
}

const updatePOStatus = `-- name: UpdatePOStatus :exec
UPDATE pos SET status = $1 WHERE id = $2
`

type UpdatePOStatusParams struct {
	Status string `json:"status"`
	ID     int64  `json:"id"`
}

func (q *Queries) UpdatePOStatus(ctx context.Context, arg UpdatePOStatusParams) error {
	_, err := q.db.Exec(ctx, updatePOStatus, arg.Status, arg.ID)
	return err
}

const updatePRStatus = `-- name: UpdatePRStatus :exec
UPDATE prs SET status = $1 WHERE id = $2
`

type UpdatePRStatusParams struct {
	Status string `json:"status"`
	ID     int64  `json:"id"`
}

func (q *Queries) UpdatePRStatus(ctx context.Context, arg UpdatePRStatusParams) error {
	_, err := q.db.Exec(ctx, updatePRStatus, arg.Status, arg.ID)
	return err
}
