// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: ap.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAPInvoice = `-- name: CreateAPInvoice :one
INSERT INTO ap_invoices (
    number, supplier_id, grn_id, po_id, currency, 
    subtotal, tax_amount, total, status, 
    due_at, created_by, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5, 
    $6, $7, $8, $9, 
    $10, $11, NOW(), NOW()
) RETURNING id
`

type CreateAPInvoiceParams struct {
	Number     string         `json:"number"`
	SupplierID int64          `json:"supplier_id"`
	GrnID      pgtype.Int8    `json:"grn_id"`
	PoID       pgtype.Int8    `json:"po_id"`
	Currency   string         `json:"currency"`
	Subtotal   pgtype.Numeric `json:"subtotal"`
	TaxAmount  pgtype.Numeric `json:"tax_amount"`
	Total      pgtype.Numeric `json:"total"`
	Status     string         `json:"status"`
	DueAt      pgtype.Date    `json:"due_at"`
	CreatedBy  pgtype.Int8    `json:"created_by"`
}

func (q *Queries) CreateAPInvoice(ctx context.Context, arg CreateAPInvoiceParams) (int64, error) {
	row := q.db.QueryRow(ctx, createAPInvoice,
		arg.Number,
		arg.SupplierID,
		arg.GrnID,
		arg.PoID,
		arg.Currency,
		arg.Subtotal,
		arg.TaxAmount,
		arg.Total,
		arg.Status,
		arg.DueAt,
		arg.CreatedBy,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createAPInvoiceLine = `-- name: CreateAPInvoiceLine :one
INSERT INTO ap_invoice_lines (
    ap_invoice_id, grn_line_id, product_id, description,
    quantity, unit_price, discount_pct, tax_pct,
    subtotal, tax_amount, total, created_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, NOW()
) RETURNING id
`

type CreateAPInvoiceLineParams struct {
	ApInvoiceID int64          `json:"ap_invoice_id"`
	GrnLineID   pgtype.Int8    `json:"grn_line_id"`
	ProductID   int64          `json:"product_id"`
	Description string         `json:"description"`
	Quantity    pgtype.Numeric `json:"quantity"`
	UnitPrice   pgtype.Numeric `json:"unit_price"`
	DiscountPct pgtype.Numeric `json:"discount_pct"`
	TaxPct      pgtype.Numeric `json:"tax_pct"`
	Subtotal    pgtype.Numeric `json:"subtotal"`
	TaxAmount   pgtype.Numeric `json:"tax_amount"`
	Total       pgtype.Numeric `json:"total"`
}

func (q *Queries) CreateAPInvoiceLine(ctx context.Context, arg CreateAPInvoiceLineParams) (int64, error) {
	row := q.db.QueryRow(ctx, createAPInvoiceLine,
		arg.ApInvoiceID,
		arg.GrnLineID,
		arg.ProductID,
		arg.Description,
		arg.Quantity,
		arg.UnitPrice,
		arg.DiscountPct,
		arg.TaxPct,
		arg.Subtotal,
		arg.TaxAmount,
		arg.Total,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createAPPayment = `-- name: CreateAPPayment :one
INSERT INTO ap_payments (
    number, ap_invoice_id, supplier_id, amount, paid_at, method, note, 
    created_by, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, NOW(), NOW()
) RETURNING id
`

type CreateAPPaymentParams struct {
	Number      string         `json:"number"`
	ApInvoiceID pgtype.Int8    `json:"ap_invoice_id"`
	SupplierID  pgtype.Int8    `json:"supplier_id"`
	Amount      pgtype.Numeric `json:"amount"`
	PaidAt      pgtype.Date    `json:"paid_at"`
	Method      string         `json:"method"`
	Note        string         `json:"note"`
	CreatedBy   pgtype.Int8    `json:"created_by"`
}

func (q *Queries) CreateAPPayment(ctx context.Context, arg CreateAPPaymentParams) (int64, error) {
	row := q.db.QueryRow(ctx, createAPPayment,
		arg.Number,
		arg.ApInvoiceID,
		arg.SupplierID,
		arg.Amount,
		arg.PaidAt,
		arg.Method,
		arg.Note,
		arg.CreatedBy,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createAPPaymentAllocation = `-- name: CreateAPPaymentAllocation :one
INSERT INTO ap_payment_allocations (
    ap_payment_id, ap_invoice_id, amount, created_at
) VALUES ($1, $2, $3, NOW())
RETURNING id
`

type CreateAPPaymentAllocationParams struct {
	ApPaymentID int64          `json:"ap_payment_id"`
	ApInvoiceID int64          `json:"ap_invoice_id"`
	Amount      pgtype.Numeric `json:"amount"`
}

func (q *Queries) CreateAPPaymentAllocation(ctx context.Context, arg CreateAPPaymentAllocationParams) (int64, error) {
	row := q.db.QueryRow(ctx, createAPPaymentAllocation, arg.ApPaymentID, arg.ApInvoiceID, arg.Amount)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const generateAPInvoiceNumber = `-- name: GenerateAPInvoiceNumber :one
SELECT 'INV-' || TO_CHAR(NOW(), 'YYYYMMDD') || '-' || LPAD(NEXTVAL('ap_invoices_id_seq')::TEXT, 4, '0')
`

func (q *Queries) GenerateAPInvoiceNumber(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRow(ctx, generateAPInvoiceNumber)
	var column_1 interface{}
	err := row.Scan(&column_1)
	return column_1, err
}

const generateAPPaymentNumber = `-- name: GenerateAPPaymentNumber :one
SELECT 'PAY-' || TO_CHAR(NOW(), 'YYYYMMDD') || '-' || LPAD(NEXTVAL('ap_payments_id_seq')::TEXT, 4, '0')
`

func (q *Queries) GenerateAPPaymentNumber(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRow(ctx, generateAPPaymentNumber)
	var column_1 interface{}
	err := row.Scan(&column_1)
	return column_1, err
}

const getAPInvoice = `-- name: GetAPInvoice :one
SELECT 
    i.id, i.number, i.supplier_id, s.name AS supplier_name, i.grn_id, i.po_id, i.currency, 
    subtotal, tax_amount, total, status, due_at, 
    posted_at, posted_by, voided_at, voided_by, void_reason,
    created_by, created_at, updated_at 
FROM ap_invoices i
JOIN suppliers s ON s.id = i.supplier_id
WHERE i.id = $1
`

type GetAPInvoiceRow struct {
	ID           int64              `json:"id"`
	Number       string             `json:"number"`
	SupplierID   int64              `json:"supplier_id"`
	SupplierName string             `json:"supplier_name"`
	GrnID        pgtype.Int8        `json:"grn_id"`
	PoID         pgtype.Int8        `json:"po_id"`
	Currency     string             `json:"currency"`
	Subtotal     pgtype.Numeric     `json:"subtotal"`
	TaxAmount    pgtype.Numeric     `json:"tax_amount"`
	Total        pgtype.Numeric     `json:"total"`
	Status       string             `json:"status"`
	DueAt        pgtype.Date        `json:"due_at"`
	PostedAt     pgtype.Timestamptz `json:"posted_at"`
	PostedBy     pgtype.Int8        `json:"posted_by"`
	VoidedAt     pgtype.Timestamptz `json:"voided_at"`
	VoidedBy     pgtype.Int8        `json:"voided_by"`
	VoidReason   pgtype.Text        `json:"void_reason"`
	CreatedBy    pgtype.Int8        `json:"created_by"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetAPInvoice(ctx context.Context, id int64) (GetAPInvoiceRow, error) {
	row := q.db.QueryRow(ctx, getAPInvoice, id)
	var i GetAPInvoiceRow
	err := row.Scan(
		&i.ID,
		&i.Number,
		&i.SupplierID,
		&i.SupplierName,
		&i.GrnID,
		&i.PoID,
		&i.Currency,
		&i.Subtotal,
		&i.TaxAmount,
		&i.Total,
		&i.Status,
		&i.DueAt,
		&i.PostedAt,
		&i.PostedBy,
		&i.VoidedAt,
		&i.VoidedBy,
		&i.VoidReason,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAPInvoiceBalance = `-- name: GetAPInvoiceBalance :one
SELECT 
    i.total,
    COALESCE(SUM(pa.amount), 0)::NUMERIC AS paid_amount,
    (i.total - COALESCE(SUM(pa.amount), 0))::NUMERIC AS balance
FROM ap_invoices i
LEFT JOIN ap_payment_allocations pa ON pa.ap_invoice_id = i.id
WHERE i.id = $1
GROUP BY i.id
`

type GetAPInvoiceBalanceRow struct {
	Total      pgtype.Numeric `json:"total"`
	PaidAmount pgtype.Numeric `json:"paid_amount"`
	Balance    pgtype.Numeric `json:"balance"`
}

func (q *Queries) GetAPInvoiceBalance(ctx context.Context, id int64) (GetAPInvoiceBalanceRow, error) {
	row := q.db.QueryRow(ctx, getAPInvoiceBalance, id)
	var i GetAPInvoiceBalanceRow
	err := row.Scan(&i.Total, &i.PaidAmount, &i.Balance)
	return i, err
}

const getAPInvoiceByNumber = `-- name: GetAPInvoiceByNumber :one
SELECT 
    i.id, i.number, i.supplier_id, s.name AS supplier_name, i.grn_id, i.po_id, i.currency, 
    subtotal, tax_amount, total, status, due_at, 
    posted_at, posted_by, voided_at, voided_by, void_reason,
    created_by, created_at, updated_at 
FROM ap_invoices i
JOIN suppliers s ON s.id = i.supplier_id
WHERE i.number = $1
`

type GetAPInvoiceByNumberRow struct {
	ID           int64              `json:"id"`
	Number       string             `json:"number"`
	SupplierID   int64              `json:"supplier_id"`
	SupplierName string             `json:"supplier_name"`
	GrnID        pgtype.Int8        `json:"grn_id"`
	PoID         pgtype.Int8        `json:"po_id"`
	Currency     string             `json:"currency"`
	Subtotal     pgtype.Numeric     `json:"subtotal"`
	TaxAmount    pgtype.Numeric     `json:"tax_amount"`
	Total        pgtype.Numeric     `json:"total"`
	Status       string             `json:"status"`
	DueAt        pgtype.Date        `json:"due_at"`
	PostedAt     pgtype.Timestamptz `json:"posted_at"`
	PostedBy     pgtype.Int8        `json:"posted_by"`
	VoidedAt     pgtype.Timestamptz `json:"voided_at"`
	VoidedBy     pgtype.Int8        `json:"voided_by"`
	VoidReason   pgtype.Text        `json:"void_reason"`
	CreatedBy    pgtype.Int8        `json:"created_by"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetAPInvoiceByNumber(ctx context.Context, number string) (GetAPInvoiceByNumberRow, error) {
	row := q.db.QueryRow(ctx, getAPInvoiceByNumber, number)
	var i GetAPInvoiceByNumberRow
	err := row.Scan(
		&i.ID,
		&i.Number,
		&i.SupplierID,
		&i.SupplierName,
		&i.GrnID,
		&i.PoID,
		&i.Currency,
		&i.Subtotal,
		&i.TaxAmount,
		&i.Total,
		&i.Status,
		&i.DueAt,
		&i.PostedAt,
		&i.PostedBy,
		&i.VoidedAt,
		&i.VoidedBy,
		&i.VoidReason,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAPInvoiceLines = `-- name: ListAPInvoiceLines :many
SELECT 
    id, ap_invoice_id, grn_line_id, product_id,
    description, quantity, unit_price, discount_pct, tax_pct,
    subtotal, tax_amount, total, created_at
FROM ap_invoice_lines
WHERE ap_invoice_id = $1
ORDER BY id
`

func (q *Queries) ListAPInvoiceLines(ctx context.Context, apInvoiceID int64) ([]ApInvoiceLine, error) {
	rows, err := q.db.Query(ctx, listAPInvoiceLines, apInvoiceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApInvoiceLine
	for rows.Next() {
		var i ApInvoiceLine
		if err := rows.Scan(
			&i.ID,
			&i.ApInvoiceID,
			&i.GrnLineID,
			&i.ProductID,
			&i.Description,
			&i.Quantity,
			&i.UnitPrice,
			&i.DiscountPct,
			&i.TaxPct,
			&i.Subtotal,
			&i.TaxAmount,
			&i.Total,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAPInvoicePayments = `-- name: ListAPInvoicePayments :many
SELECT 
    p.id, p.number, p.amount, p.paid_at, p.method, p.note,
    pa.amount AS allocated_amount
FROM ap_payments p
JOIN ap_payment_allocations pa ON pa.ap_payment_id = p.id
WHERE pa.ap_invoice_id = $1
ORDER BY p.paid_at
`

type ListAPInvoicePaymentsRow struct {
	ID              int64          `json:"id"`
	Number          string         `json:"number"`
	Amount          pgtype.Numeric `json:"amount"`
	PaidAt          pgtype.Date    `json:"paid_at"`
	Method          string         `json:"method"`
	Note            string         `json:"note"`
	AllocatedAmount pgtype.Numeric `json:"allocated_amount"`
}

func (q *Queries) ListAPInvoicePayments(ctx context.Context, apInvoiceID int64) ([]ListAPInvoicePaymentsRow, error) {
	rows, err := q.db.Query(ctx, listAPInvoicePayments, apInvoiceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAPInvoicePaymentsRow
	for rows.Next() {
		var i ListAPInvoicePaymentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Number,
			&i.Amount,
			&i.PaidAt,
			&i.Method,
			&i.Note,
			&i.AllocatedAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAPInvoices = `-- name: ListAPInvoices :many
SELECT 
    i.id, i.number, i.supplier_id, s.name AS supplier_name, i.grn_id, i.po_id, i.currency, 
    subtotal, tax_amount, total, status, due_at, 
    posted_at, posted_by, voided_at, voided_by, void_reason,
    created_by, created_at, updated_at 
FROM ap_invoices i
JOIN suppliers s ON s.id = i.supplier_id
ORDER BY i.created_at DESC
`

type ListAPInvoicesRow struct {
	ID           int64              `json:"id"`
	Number       string             `json:"number"`
	SupplierID   int64              `json:"supplier_id"`
	SupplierName string             `json:"supplier_name"`
	GrnID        pgtype.Int8        `json:"grn_id"`
	PoID         pgtype.Int8        `json:"po_id"`
	Currency     string             `json:"currency"`
	Subtotal     pgtype.Numeric     `json:"subtotal"`
	TaxAmount    pgtype.Numeric     `json:"tax_amount"`
	Total        pgtype.Numeric     `json:"total"`
	Status       string             `json:"status"`
	DueAt        pgtype.Date        `json:"due_at"`
	PostedAt     pgtype.Timestamptz `json:"posted_at"`
	PostedBy     pgtype.Int8        `json:"posted_by"`
	VoidedAt     pgtype.Timestamptz `json:"voided_at"`
	VoidedBy     pgtype.Int8        `json:"voided_by"`
	VoidReason   pgtype.Text        `json:"void_reason"`
	CreatedBy    pgtype.Int8        `json:"created_by"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ListAPInvoices(ctx context.Context) ([]ListAPInvoicesRow, error) {
	rows, err := q.db.Query(ctx, listAPInvoices)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAPInvoicesRow
	for rows.Next() {
		var i ListAPInvoicesRow
		if err := rows.Scan(
			&i.ID,
			&i.Number,
			&i.SupplierID,
			&i.SupplierName,
			&i.GrnID,
			&i.PoID,
			&i.Currency,
			&i.Subtotal,
			&i.TaxAmount,
			&i.Total,
			&i.Status,
			&i.DueAt,
			&i.PostedAt,
			&i.PostedBy,
			&i.VoidedAt,
			&i.VoidedBy,
			&i.VoidReason,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAPInvoicesByStatus = `-- name: ListAPInvoicesByStatus :many
SELECT 
    i.id, i.number, i.supplier_id, s.name AS supplier_name, i.grn_id, i.po_id, i.currency, 
    subtotal, tax_amount, total, status, due_at, 
    posted_at, posted_by, voided_at, voided_by, void_reason,
    created_by, created_at, updated_at 
FROM ap_invoices i
JOIN suppliers s ON s.id = i.supplier_id
WHERE i.status = $1
ORDER BY i.created_at DESC
`

type ListAPInvoicesByStatusRow struct {
	ID           int64              `json:"id"`
	Number       string             `json:"number"`
	SupplierID   int64              `json:"supplier_id"`
	SupplierName string             `json:"supplier_name"`
	GrnID        pgtype.Int8        `json:"grn_id"`
	PoID         pgtype.Int8        `json:"po_id"`
	Currency     string             `json:"currency"`
	Subtotal     pgtype.Numeric     `json:"subtotal"`
	TaxAmount    pgtype.Numeric     `json:"tax_amount"`
	Total        pgtype.Numeric     `json:"total"`
	Status       string             `json:"status"`
	DueAt        pgtype.Date        `json:"due_at"`
	PostedAt     pgtype.Timestamptz `json:"posted_at"`
	PostedBy     pgtype.Int8        `json:"posted_by"`
	VoidedAt     pgtype.Timestamptz `json:"voided_at"`
	VoidedBy     pgtype.Int8        `json:"voided_by"`
	VoidReason   pgtype.Text        `json:"void_reason"`
	CreatedBy    pgtype.Int8        `json:"created_by"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ListAPInvoicesByStatus(ctx context.Context, status string) ([]ListAPInvoicesByStatusRow, error) {
	rows, err := q.db.Query(ctx, listAPInvoicesByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAPInvoicesByStatusRow
	for rows.Next() {
		var i ListAPInvoicesByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.Number,
			&i.SupplierID,
			&i.SupplierName,
			&i.GrnID,
			&i.PoID,
			&i.Currency,
			&i.Subtotal,
			&i.TaxAmount,
			&i.Total,
			&i.Status,
			&i.DueAt,
			&i.PostedAt,
			&i.PostedBy,
			&i.VoidedAt,
			&i.VoidedBy,
			&i.VoidReason,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAPInvoicesBySupplier = `-- name: ListAPInvoicesBySupplier :many
SELECT 
    i.id, i.number, i.supplier_id, s.name AS supplier_name, i.grn_id, i.po_id, i.currency, 
    subtotal, tax_amount, total, status, due_at, 
    posted_at, posted_by, voided_at, voided_by, void_reason,
    created_by, created_at, updated_at 
FROM ap_invoices i
JOIN suppliers s ON s.id = i.supplier_id
WHERE i.supplier_id = $1
ORDER BY i.created_at DESC
`

type ListAPInvoicesBySupplierRow struct {
	ID           int64              `json:"id"`
	Number       string             `json:"number"`
	SupplierID   int64              `json:"supplier_id"`
	SupplierName string             `json:"supplier_name"`
	GrnID        pgtype.Int8        `json:"grn_id"`
	PoID         pgtype.Int8        `json:"po_id"`
	Currency     string             `json:"currency"`
	Subtotal     pgtype.Numeric     `json:"subtotal"`
	TaxAmount    pgtype.Numeric     `json:"tax_amount"`
	Total        pgtype.Numeric     `json:"total"`
	Status       string             `json:"status"`
	DueAt        pgtype.Date        `json:"due_at"`
	PostedAt     pgtype.Timestamptz `json:"posted_at"`
	PostedBy     pgtype.Int8        `json:"posted_by"`
	VoidedAt     pgtype.Timestamptz `json:"voided_at"`
	VoidedBy     pgtype.Int8        `json:"voided_by"`
	VoidReason   pgtype.Text        `json:"void_reason"`
	CreatedBy    pgtype.Int8        `json:"created_by"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ListAPInvoicesBySupplier(ctx context.Context, supplierID int64) ([]ListAPInvoicesBySupplierRow, error) {
	rows, err := q.db.Query(ctx, listAPInvoicesBySupplier, supplierID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAPInvoicesBySupplierRow
	for rows.Next() {
		var i ListAPInvoicesBySupplierRow
		if err := rows.Scan(
			&i.ID,
			&i.Number,
			&i.SupplierID,
			&i.SupplierName,
			&i.GrnID,
			&i.PoID,
			&i.Currency,
			&i.Subtotal,
			&i.TaxAmount,
			&i.Total,
			&i.Status,
			&i.DueAt,
			&i.PostedAt,
			&i.PostedBy,
			&i.VoidedAt,
			&i.VoidedBy,
			&i.VoidReason,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAPPayments = `-- name: ListAPPayments :many
SELECT 
    p.id, p.number, p.ap_invoice_id, p.supplier_id, COALESCE(s.name, '') AS supplier_name, p.amount, p.paid_at, p.method, p.note, 
    p.created_by, p.created_at, p.updated_at 
FROM ap_payments p
LEFT JOIN suppliers s ON s.id = p.supplier_id
ORDER BY p.paid_at DESC
`

type ListAPPaymentsRow struct {
	ID           int64              `json:"id"`
	Number       string             `json:"number"`
	ApInvoiceID  pgtype.Int8        `json:"ap_invoice_id"`
	SupplierID   pgtype.Int8        `json:"supplier_id"`
	SupplierName string             `json:"supplier_name"`
	Amount       pgtype.Numeric     `json:"amount"`
	PaidAt       pgtype.Date        `json:"paid_at"`
	Method       string             `json:"method"`
	Note         string             `json:"note"`
	CreatedBy    pgtype.Int8        `json:"created_by"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ListAPPayments(ctx context.Context) ([]ListAPPaymentsRow, error) {
	rows, err := q.db.Query(ctx, listAPPayments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAPPaymentsRow
	for rows.Next() {
		var i ListAPPaymentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Number,
			&i.ApInvoiceID,
			&i.SupplierID,
			&i.SupplierName,
			&i.Amount,
			&i.PaidAt,
			&i.Method,
			&i.Note,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const postAPInvoice = `-- name: PostAPInvoice :exec
UPDATE ap_invoices 
SET status = 'POSTED', posted_at = NOW(), posted_by = $2, updated_at = NOW()
WHERE id = $1 AND status = 'DRAFT'
`

type PostAPInvoiceParams struct {
	ID       int64       `json:"id"`
	PostedBy pgtype.Int8 `json:"posted_by"`
}

func (q *Queries) PostAPInvoice(ctx context.Context, arg PostAPInvoiceParams) error {
	_, err := q.db.Exec(ctx, postAPInvoice, arg.ID, arg.PostedBy)
	return err
}

const updateAPStatus = `-- name: UpdateAPStatus :exec
UPDATE ap_invoices 
SET status = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateAPStatusParams struct {
	ID     int64  `json:"id"`
	Status string `json:"status"`
}

func (q *Queries) UpdateAPStatus(ctx context.Context, arg UpdateAPStatusParams) error {
	_, err := q.db.Exec(ctx, updateAPStatus, arg.ID, arg.Status)
	return err
}

const voidAPInvoice = `-- name: VoidAPInvoice :exec
UPDATE ap_invoices 
SET status = 'VOID', voided_at = NOW(), voided_by = $2, void_reason = $3, updated_at = NOW()
WHERE id = $1 AND status IN ('DRAFT', 'POSTED')
`

type VoidAPInvoiceParams struct {
	ID         int64       `json:"id"`
	VoidedBy   pgtype.Int8 `json:"voided_by"`
	VoidReason pgtype.Text `json:"void_reason"`
}

func (q *Queries) VoidAPInvoice(ctx context.Context, arg VoidAPInvoiceParams) error {
	_, err := q.db.Exec(ctx, voidAPInvoice, arg.ID, arg.VoidedBy, arg.VoidReason)
	return err
}
