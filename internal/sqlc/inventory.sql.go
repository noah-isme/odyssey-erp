// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: inventory.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getBalanceForUpdate = `-- name: GetBalanceForUpdate :one
SELECT warehouse_id, product_id, qty, avg_cost, updated_at 
FROM inventory_balances 
WHERE warehouse_id = $1 AND product_id = $2 
FOR UPDATE
`

type GetBalanceForUpdateParams struct {
	WarehouseID int64 `json:"warehouse_id"`
	ProductID   int64 `json:"product_id"`
}

func (q *Queries) GetBalanceForUpdate(ctx context.Context, arg GetBalanceForUpdateParams) (InventoryBalance, error) {
	row := q.db.QueryRow(ctx, getBalanceForUpdate, arg.WarehouseID, arg.ProductID)
	var i InventoryBalance
	err := row.Scan(
		&i.WarehouseID,
		&i.ProductID,
		&i.Qty,
		&i.AvgCost,
		&i.UpdatedAt,
	)
	return i, err
}

const getStockCard = `-- name: GetStockCard :many
SELECT tx_code, tx_type, posted_at, qty_in, qty_out, balance_qty, unit_cost, balance_cost, note
FROM inventory_cards
WHERE warehouse_id = $1 
  AND product_id = $2 
  AND posted_at >= COALESCE($4::timestamptz, '-infinity') 
  AND posted_at <= COALESCE($5::timestamptz, 'infinity')
ORDER BY posted_at ASC, id ASC
LIMIT $3
`

type GetStockCardParams struct {
	WarehouseID int64              `json:"warehouse_id"`
	ProductID   int64              `json:"product_id"`
	Limit       int32              `json:"limit"`
	FromDate    pgtype.Timestamptz `json:"from_date"`
	ToDate      pgtype.Timestamptz `json:"to_date"`
}

type GetStockCardRow struct {
	TxCode      string             `json:"tx_code"`
	TxType      string             `json:"tx_type"`
	PostedAt    pgtype.Timestamptz `json:"posted_at"`
	QtyIn       pgtype.Numeric     `json:"qty_in"`
	QtyOut      pgtype.Numeric     `json:"qty_out"`
	BalanceQty  pgtype.Numeric     `json:"balance_qty"`
	UnitCost    pgtype.Numeric     `json:"unit_cost"`
	BalanceCost pgtype.Numeric     `json:"balance_cost"`
	Note        string             `json:"note"`
}

func (q *Queries) GetStockCard(ctx context.Context, arg GetStockCardParams) ([]GetStockCardRow, error) {
	rows, err := q.db.Query(ctx, getStockCard,
		arg.WarehouseID,
		arg.ProductID,
		arg.Limit,
		arg.FromDate,
		arg.ToDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStockCardRow
	for rows.Next() {
		var i GetStockCardRow
		if err := rows.Scan(
			&i.TxCode,
			&i.TxType,
			&i.PostedAt,
			&i.QtyIn,
			&i.QtyOut,
			&i.BalanceQty,
			&i.UnitCost,
			&i.BalanceCost,
			&i.Note,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertCardEntry = `-- name: InsertCardEntry :exec
INSERT INTO inventory_cards (
    warehouse_id, product_id, tx_id, tx_code, tx_type, 
    qty_in, qty_out, balance_qty, unit_cost, balance_cost, 
    posted_at, note
) VALUES (
    $1, $2, $3, $4, $5, 
    $6, $7, $8, $9, $10, 
    $11, $12
)
`

type InsertCardEntryParams struct {
	WarehouseID int64              `json:"warehouse_id"`
	ProductID   int64              `json:"product_id"`
	TxID        int64              `json:"tx_id"`
	TxCode      string             `json:"tx_code"`
	TxType      string             `json:"tx_type"`
	QtyIn       pgtype.Numeric     `json:"qty_in"`
	QtyOut      pgtype.Numeric     `json:"qty_out"`
	BalanceQty  pgtype.Numeric     `json:"balance_qty"`
	UnitCost    pgtype.Numeric     `json:"unit_cost"`
	BalanceCost pgtype.Numeric     `json:"balance_cost"`
	PostedAt    pgtype.Timestamptz `json:"posted_at"`
	Note        string             `json:"note"`
}

func (q *Queries) InsertCardEntry(ctx context.Context, arg InsertCardEntryParams) error {
	_, err := q.db.Exec(ctx, insertCardEntry,
		arg.WarehouseID,
		arg.ProductID,
		arg.TxID,
		arg.TxCode,
		arg.TxType,
		arg.QtyIn,
		arg.QtyOut,
		arg.BalanceQty,
		arg.UnitCost,
		arg.BalanceCost,
		arg.PostedAt,
		arg.Note,
	)
	return err
}

const insertTransaction = `-- name: InsertTransaction :one
INSERT INTO inventory_tx (
    code, tx_type, warehouse_id, ref_module, ref_id, note, posted_at, created_by, created_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, NOW()
) RETURNING id
`

type InsertTransactionParams struct {
	Code        string             `json:"code"`
	TxType      string             `json:"tx_type"`
	WarehouseID pgtype.Int8        `json:"warehouse_id"`
	RefModule   string             `json:"ref_module"`
	RefID       pgtype.UUID        `json:"ref_id"`
	Note        string             `json:"note"`
	PostedAt    pgtype.Timestamptz `json:"posted_at"`
	CreatedBy   pgtype.Int8        `json:"created_by"`
}

func (q *Queries) InsertTransaction(ctx context.Context, arg InsertTransactionParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertTransaction,
		arg.Code,
		arg.TxType,
		arg.WarehouseID,
		arg.RefModule,
		arg.RefID,
		arg.Note,
		arg.PostedAt,
		arg.CreatedBy,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertTransactionLine = `-- name: InsertTransactionLine :exec
INSERT INTO inventory_tx_lines (
    tx_id, product_id, qty, unit_cost, src_warehouse_id, dst_warehouse_id
) VALUES (
    $1, $2, $3, $4, $5, $6
)
`

type InsertTransactionLineParams struct {
	TxID           int64          `json:"tx_id"`
	ProductID      int64          `json:"product_id"`
	Qty            pgtype.Numeric `json:"qty"`
	UnitCost       pgtype.Numeric `json:"unit_cost"`
	SrcWarehouseID pgtype.Int8    `json:"src_warehouse_id"`
	DstWarehouseID pgtype.Int8    `json:"dst_warehouse_id"`
}

func (q *Queries) InsertTransactionLine(ctx context.Context, arg InsertTransactionLineParams) error {
	_, err := q.db.Exec(ctx, insertTransactionLine,
		arg.TxID,
		arg.ProductID,
		arg.Qty,
		arg.UnitCost,
		arg.SrcWarehouseID,
		arg.DstWarehouseID,
	)
	return err
}

const upsertBalance = `-- name: UpsertBalance :exec
INSERT INTO inventory_balances (
    warehouse_id, product_id, qty, avg_cost, updated_at
) VALUES (
    $1, $2, $3, $4, NOW()
)
ON CONFLICT (warehouse_id, product_id) 
DO UPDATE SET 
    qty = EXCLUDED.qty, 
    avg_cost = EXCLUDED.avg_cost, 
    updated_at = NOW()
`

type UpsertBalanceParams struct {
	WarehouseID int64          `json:"warehouse_id"`
	ProductID   int64          `json:"product_id"`
	Qty         pgtype.Numeric `json:"qty"`
	AvgCost     pgtype.Numeric `json:"avg_cost"`
}

func (q *Queries) UpsertBalance(ctx context.Context, arg UpsertBalanceParams) error {
	_, err := q.db.Exec(ctx, upsertBalance,
		arg.WarehouseID,
		arg.ProductID,
		arg.Qty,
		arg.AvgCost,
	)
	return err
}
