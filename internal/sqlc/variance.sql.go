// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: variance.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const aggregateBalances = `-- name: AggregateBalances :many
SELECT acc.code, acc.name, SUM(jl.debit - jl.credit)::float8 AS amount
FROM journal_lines jl
JOIN journal_entries je ON je.id = jl.je_id AND je.status = 'POSTED'
JOIN accounts acc ON acc.id = jl.account_id
JOIN accounting_periods ap ON ap.id = $1
WHERE je.period_id = ap.period_id AND COALESCE(jl.dim_company_id, 0) = $2
GROUP BY acc.code, acc.name
`

type AggregateBalancesParams struct {
	ID           int64       `json:"id"`
	DimCompanyID pgtype.Int8 `json:"dim_company_id"`
}

type AggregateBalancesRow struct {
	Code   string  `json:"code"`
	Name   string  `json:"name"`
	Amount float64 `json:"amount"`
}

func (q *Queries) AggregateBalances(ctx context.Context, arg AggregateBalancesParams) ([]AggregateBalancesRow, error) {
	rows, err := q.db.Query(ctx, aggregateBalances, arg.ID, arg.DimCompanyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AggregateBalancesRow
	for rows.Next() {
		var i AggregateBalancesRow
		if err := rows.Scan(&i.Code, &i.Name, &i.Amount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSnapshot = `-- name: GetSnapshot :one
SELECT vs.id, vs.rule_id, vs.period_id, vs.status, vs.generated_at, vs.generated_by, vs.error_message, vs.payload,
       vs.created_at, vs.updated_at,
       vr.id, vr.company_id, vr.name, vr.comparison_type, vr.base_period_id, vr.compare_period_id, vr.dimension_filters,
       vr.threshold_amount::float8, vr.threshold_percent::float8, vr.is_active, vr.created_by, vr.created_at
FROM variance_snapshots vs
JOIN variance_rules vr ON vr.id = vs.rule_id
WHERE vs.id = $1
`

type GetSnapshotRow struct {
	ID                 int64                  `json:"id"`
	RuleID             int64                  `json:"rule_id"`
	PeriodID           int64                  `json:"period_id"`
	Status             VarianceSnapshotStatus `json:"status"`
	GeneratedAt        pgtype.Timestamptz     `json:"generated_at"`
	GeneratedBy        pgtype.Int8            `json:"generated_by"`
	ErrorMessage       pgtype.Text            `json:"error_message"`
	Payload            []byte                 `json:"payload"`
	CreatedAt          pgtype.Timestamptz     `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz     `json:"updated_at"`
	ID_2               int64                  `json:"id_2"`
	CompanyID          int64                  `json:"company_id"`
	Name               string                 `json:"name"`
	ComparisonType     string                 `json:"comparison_type"`
	BasePeriodID       int64                  `json:"base_period_id"`
	ComparePeriodID    pgtype.Int8            `json:"compare_period_id"`
	DimensionFilters   []byte                 `json:"dimension_filters"`
	VrThresholdAmount  float64                `json:"vr_threshold_amount"`
	VrThresholdPercent float64                `json:"vr_threshold_percent"`
	IsActive           bool                   `json:"is_active"`
	CreatedBy          int64                  `json:"created_by"`
	CreatedAt_2        pgtype.Timestamptz     `json:"created_at_2"`
}

func (q *Queries) GetSnapshot(ctx context.Context, id int64) (GetSnapshotRow, error) {
	row := q.db.QueryRow(ctx, getSnapshot, id)
	var i GetSnapshotRow
	err := row.Scan(
		&i.ID,
		&i.RuleID,
		&i.PeriodID,
		&i.Status,
		&i.GeneratedAt,
		&i.GeneratedBy,
		&i.ErrorMessage,
		&i.Payload,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ID_2,
		&i.CompanyID,
		&i.Name,
		&i.ComparisonType,
		&i.BasePeriodID,
		&i.ComparePeriodID,
		&i.DimensionFilters,
		&i.VrThresholdAmount,
		&i.VrThresholdPercent,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt_2,
	)
	return i, err
}

const insertSnapshot = `-- name: InsertSnapshot :one
INSERT INTO variance_snapshots (rule_id, period_id, status, generated_by)
VALUES ($1,$2,'PENDING',$3)
RETURNING id, rule_id, period_id, status, generated_at, generated_by, error_message, payload, created_at, updated_at
`

type InsertSnapshotParams struct {
	RuleID      int64       `json:"rule_id"`
	PeriodID    int64       `json:"period_id"`
	GeneratedBy pgtype.Int8 `json:"generated_by"`
}

func (q *Queries) InsertSnapshot(ctx context.Context, arg InsertSnapshotParams) (VarianceSnapshot, error) {
	row := q.db.QueryRow(ctx, insertSnapshot, arg.RuleID, arg.PeriodID, arg.GeneratedBy)
	var i VarianceSnapshot
	err := row.Scan(
		&i.ID,
		&i.RuleID,
		&i.PeriodID,
		&i.Status,
		&i.GeneratedAt,
		&i.GeneratedBy,
		&i.ErrorMessage,
		&i.Payload,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listSnapshots = `-- name: ListSnapshots :many
SELECT vs.id, vs.rule_id, vs.period_id, vs.status, vs.generated_at, vs.generated_by, vs.error_message, vs.payload,
       vs.created_at, vs.updated_at,
       vr.id, vr.company_id, vr.name, vr.comparison_type, vr.base_period_id, vr.compare_period_id, vr.dimension_filters,
       vr.threshold_amount::float8, vr.threshold_percent::float8, vr.is_active, vr.created_by, vr.created_at
FROM variance_snapshots vs
JOIN variance_rules vr ON vr.id = vs.rule_id
ORDER BY
  CASE WHEN $3::text = 'created_at' AND $4::text = 'asc' THEN vs.created_at END ASC,
  CASE WHEN $3::text = 'created_at' AND $4::text = 'desc' THEN vs.created_at END DESC,
  CASE WHEN $3::text = 'status' AND $4::text = 'asc' THEN vs.status END ASC,
  CASE WHEN $3::text = 'status' AND $4::text = 'desc' THEN vs.status END DESC,
  CASE WHEN $3::text = 'period_id' AND $4::text = 'asc' THEN vs.period_id END ASC,
  CASE WHEN $3::text = 'period_id' AND $4::text = 'desc' THEN vs.period_id END DESC,
  vs.created_at DESC -- Default
LIMIT $1 OFFSET $2
`

type ListSnapshotsParams struct {
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
	SortBy  string `json:"sort_by"`
	SortDir string `json:"sort_dir"`
}

type ListSnapshotsRow struct {
	ID                 int64                  `json:"id"`
	RuleID             int64                  `json:"rule_id"`
	PeriodID           int64                  `json:"period_id"`
	Status             VarianceSnapshotStatus `json:"status"`
	GeneratedAt        pgtype.Timestamptz     `json:"generated_at"`
	GeneratedBy        pgtype.Int8            `json:"generated_by"`
	ErrorMessage       pgtype.Text            `json:"error_message"`
	Payload            []byte                 `json:"payload"`
	CreatedAt          pgtype.Timestamptz     `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz     `json:"updated_at"`
	ID_2               int64                  `json:"id_2"`
	CompanyID          int64                  `json:"company_id"`
	Name               string                 `json:"name"`
	ComparisonType     string                 `json:"comparison_type"`
	BasePeriodID       int64                  `json:"base_period_id"`
	ComparePeriodID    pgtype.Int8            `json:"compare_period_id"`
	DimensionFilters   []byte                 `json:"dimension_filters"`
	VrThresholdAmount  float64                `json:"vr_threshold_amount"`
	VrThresholdPercent float64                `json:"vr_threshold_percent"`
	IsActive           bool                   `json:"is_active"`
	CreatedBy          int64                  `json:"created_by"`
	CreatedAt_2        pgtype.Timestamptz     `json:"created_at_2"`
}

func (q *Queries) ListSnapshots(ctx context.Context, arg ListSnapshotsParams) ([]ListSnapshotsRow, error) {
	rows, err := q.db.Query(ctx, listSnapshots,
		arg.Limit,
		arg.Offset,
		arg.SortBy,
		arg.SortDir,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSnapshotsRow
	for rows.Next() {
		var i ListSnapshotsRow
		if err := rows.Scan(
			&i.ID,
			&i.RuleID,
			&i.PeriodID,
			&i.Status,
			&i.GeneratedAt,
			&i.GeneratedBy,
			&i.ErrorMessage,
			&i.Payload,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.CompanyID,
			&i.Name,
			&i.ComparisonType,
			&i.BasePeriodID,
			&i.ComparePeriodID,
			&i.DimensionFilters,
			&i.VrThresholdAmount,
			&i.VrThresholdPercent,
			&i.IsActive,
			&i.CreatedBy,
			&i.CreatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const loadPayload = `-- name: LoadPayload :one
SELECT payload FROM variance_snapshots WHERE id = $1
`

func (q *Queries) LoadPayload(ctx context.Context, id int64) ([]byte, error) {
	row := q.db.QueryRow(ctx, loadPayload, id)
	var payload []byte
	err := row.Scan(&payload)
	return payload, err
}

const savePayload = `-- name: SavePayload :exec
UPDATE variance_snapshots
SET payload = $2,
    error_message = $3,
    updated_at = NOW(),
    generated_at = CASE WHEN $3::text IS NULL OR $3::text = '' THEN NOW() ELSE generated_at END
WHERE id = $1
`

type SavePayloadParams struct {
	ID           int64       `json:"id"`
	Payload      []byte      `json:"payload"`
	ErrorMessage pgtype.Text `json:"error_message"`
}

func (q *Queries) SavePayload(ctx context.Context, arg SavePayloadParams) error {
	_, err := q.db.Exec(ctx, savePayload, arg.ID, arg.Payload, arg.ErrorMessage)
	return err
}

const varGetRule = `-- name: VarGetRule :one
SELECT id, company_id, name, comparison_type, base_period_id, compare_period_id, dimension_filters,
       threshold_amount::float8, threshold_percent::float8, is_active, created_by, created_at
FROM variance_rules WHERE id = $1
`

type VarGetRuleRow struct {
	ID               int64              `json:"id"`
	CompanyID        int64              `json:"company_id"`
	Name             string             `json:"name"`
	ComparisonType   string             `json:"comparison_type"`
	BasePeriodID     int64              `json:"base_period_id"`
	ComparePeriodID  pgtype.Int8        `json:"compare_period_id"`
	DimensionFilters []byte             `json:"dimension_filters"`
	ThresholdAmount  float64            `json:"threshold_amount"`
	ThresholdPercent float64            `json:"threshold_percent"`
	IsActive         bool               `json:"is_active"`
	CreatedBy        int64              `json:"created_by"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) VarGetRule(ctx context.Context, id int64) (VarGetRuleRow, error) {
	row := q.db.QueryRow(ctx, varGetRule, id)
	var i VarGetRuleRow
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Name,
		&i.ComparisonType,
		&i.BasePeriodID,
		&i.ComparePeriodID,
		&i.DimensionFilters,
		&i.ThresholdAmount,
		&i.ThresholdPercent,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const varInsertRule = `-- name: VarInsertRule :one
INSERT INTO variance_rules (company_id, name, comparison_type, base_period_id, compare_period_id, created_by)
VALUES ($1,$2,$3,$4,$5,$6)
RETURNING id, company_id, name, comparison_type, base_period_id, compare_period_id, dimension_filters,
          threshold_amount::float8, threshold_percent::float8, is_active, created_by, created_at
`

type VarInsertRuleParams struct {
	CompanyID       int64       `json:"company_id"`
	Name            string      `json:"name"`
	ComparisonType  string      `json:"comparison_type"`
	BasePeriodID    int64       `json:"base_period_id"`
	ComparePeriodID pgtype.Int8 `json:"compare_period_id"`
	CreatedBy       int64       `json:"created_by"`
}

type VarInsertRuleRow struct {
	ID               int64              `json:"id"`
	CompanyID        int64              `json:"company_id"`
	Name             string             `json:"name"`
	ComparisonType   string             `json:"comparison_type"`
	BasePeriodID     int64              `json:"base_period_id"`
	ComparePeriodID  pgtype.Int8        `json:"compare_period_id"`
	DimensionFilters []byte             `json:"dimension_filters"`
	ThresholdAmount  float64            `json:"threshold_amount"`
	ThresholdPercent float64            `json:"threshold_percent"`
	IsActive         bool               `json:"is_active"`
	CreatedBy        int64              `json:"created_by"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) VarInsertRule(ctx context.Context, arg VarInsertRuleParams) (VarInsertRuleRow, error) {
	row := q.db.QueryRow(ctx, varInsertRule,
		arg.CompanyID,
		arg.Name,
		arg.ComparisonType,
		arg.BasePeriodID,
		arg.ComparePeriodID,
		arg.CreatedBy,
	)
	var i VarInsertRuleRow
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Name,
		&i.ComparisonType,
		&i.BasePeriodID,
		&i.ComparePeriodID,
		&i.DimensionFilters,
		&i.ThresholdAmount,
		&i.ThresholdPercent,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const varListRules = `-- name: VarListRules :many
SELECT id, company_id, name, comparison_type, base_period_id, compare_period_id, dimension_filters,
       threshold_amount::float8, threshold_percent::float8, is_active, created_by, created_at
FROM variance_rules
WHERE ($1::bigint = 0 OR company_id = $1)
ORDER BY created_at DESC
LIMIT 100
`

type VarListRulesRow struct {
	ID               int64              `json:"id"`
	CompanyID        int64              `json:"company_id"`
	Name             string             `json:"name"`
	ComparisonType   string             `json:"comparison_type"`
	BasePeriodID     int64              `json:"base_period_id"`
	ComparePeriodID  pgtype.Int8        `json:"compare_period_id"`
	DimensionFilters []byte             `json:"dimension_filters"`
	ThresholdAmount  float64            `json:"threshold_amount"`
	ThresholdPercent float64            `json:"threshold_percent"`
	IsActive         bool               `json:"is_active"`
	CreatedBy        int64              `json:"created_by"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) VarListRules(ctx context.Context, companyID int64) ([]VarListRulesRow, error) {
	rows, err := q.db.Query(ctx, varListRules, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VarListRulesRow
	for rows.Next() {
		var i VarListRulesRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.Name,
			&i.ComparisonType,
			&i.BasePeriodID,
			&i.ComparePeriodID,
			&i.DimensionFilters,
			&i.ThresholdAmount,
			&i.ThresholdPercent,
			&i.IsActive,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const varLoadAccountingPeriod = `-- name: VarLoadAccountingPeriod :one
SELECT ap.id, ap.period_id, ap.name, ap.start_date, ap.end_date
FROM accounting_periods ap WHERE ap.id = $1
`

type VarLoadAccountingPeriodRow struct {
	ID        int64       `json:"id"`
	PeriodID  int64       `json:"period_id"`
	Name      string      `json:"name"`
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
}

func (q *Queries) VarLoadAccountingPeriod(ctx context.Context, id int64) (VarLoadAccountingPeriodRow, error) {
	row := q.db.QueryRow(ctx, varLoadAccountingPeriod, id)
	var i VarLoadAccountingPeriodRow
	err := row.Scan(
		&i.ID,
		&i.PeriodID,
		&i.Name,
		&i.StartDate,
		&i.EndDate,
	)
	return i, err
}

const varUpdateStatus = `-- name: VarUpdateStatus :exec
UPDATE variance_snapshots SET status = $2, updated_at = NOW() WHERE id = $1
`

type VarUpdateStatusParams struct {
	ID     int64                  `json:"id"`
	Status VarianceSnapshotStatus `json:"status"`
}

func (q *Queries) VarUpdateStatus(ctx context.Context, arg VarUpdateStatusParams) error {
	_, err := q.db.Exec(ctx, varUpdateStatus, arg.ID, arg.Status)
	return err
}
