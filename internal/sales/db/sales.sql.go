// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sales.sql

package salesdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCustomer = `-- name: CreateCustomer :one
INSERT INTO customers (
    code, name, company_id, email, phone, tax_id,
    credit_limit, payment_terms_days, address_line1, address_line2,
    city, state, postal_code, country, is_active, notes, created_by
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17)
RETURNING id
`

type CreateCustomerParams struct {
	Code             string         `json:"code"`
	Name             string         `json:"name"`
	CompanyID        int64          `json:"company_id"`
	Email            pgtype.Text    `json:"email"`
	Phone            pgtype.Text    `json:"phone"`
	TaxID            pgtype.Text    `json:"tax_id"`
	CreditLimit      pgtype.Numeric `json:"credit_limit"`
	PaymentTermsDays int32          `json:"payment_terms_days"`
	AddressLine1     pgtype.Text    `json:"address_line1"`
	AddressLine2     pgtype.Text    `json:"address_line2"`
	City             pgtype.Text    `json:"city"`
	State            pgtype.Text    `json:"state"`
	PostalCode       pgtype.Text    `json:"postal_code"`
	Country          string         `json:"country"`
	IsActive         bool           `json:"is_active"`
	Notes            pgtype.Text    `json:"notes"`
	CreatedBy        int64          `json:"created_by"`
}

func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) (int64, error) {
	row := q.db.QueryRow(ctx, createCustomer,
		arg.Code,
		arg.Name,
		arg.CompanyID,
		arg.Email,
		arg.Phone,
		arg.TaxID,
		arg.CreditLimit,
		arg.PaymentTermsDays,
		arg.AddressLine1,
		arg.AddressLine2,
		arg.City,
		arg.State,
		arg.PostalCode,
		arg.Country,
		arg.IsActive,
		arg.Notes,
		arg.CreatedBy,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createQuotation = `-- name: CreateQuotation :one
INSERT INTO quotations (
    doc_number, company_id, customer_id, quote_date, valid_until,
    status, currency, subtotal, tax_amount, total_amount, notes, created_by
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
RETURNING id
`

type CreateQuotationParams struct {
	DocNumber   string          `json:"doc_number"`
	CompanyID   int64           `json:"company_id"`
	CustomerID  int64           `json:"customer_id"`
	QuoteDate   pgtype.Date     `json:"quote_date"`
	ValidUntil  pgtype.Date     `json:"valid_until"`
	Status      QuotationStatus `json:"status"`
	Currency    string          `json:"currency"`
	Subtotal    pgtype.Numeric  `json:"subtotal"`
	TaxAmount   pgtype.Numeric  `json:"tax_amount"`
	TotalAmount pgtype.Numeric  `json:"total_amount"`
	Notes       pgtype.Text     `json:"notes"`
	CreatedBy   int64           `json:"created_by"`
}

func (q *Queries) CreateQuotation(ctx context.Context, arg CreateQuotationParams) (int64, error) {
	row := q.db.QueryRow(ctx, createQuotation,
		arg.DocNumber,
		arg.CompanyID,
		arg.CustomerID,
		arg.QuoteDate,
		arg.ValidUntil,
		arg.Status,
		arg.Currency,
		arg.Subtotal,
		arg.TaxAmount,
		arg.TotalAmount,
		arg.Notes,
		arg.CreatedBy,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createSalesOrder = `-- name: CreateSalesOrder :one
INSERT INTO sales_orders (
    doc_number, company_id, customer_id, quotation_id, order_date,
    expected_delivery_date, status, currency, subtotal, tax_amount,
    total_amount, notes, created_by
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
RETURNING id
`

type CreateSalesOrderParams struct {
	DocNumber            string           `json:"doc_number"`
	CompanyID            int64            `json:"company_id"`
	CustomerID           int64            `json:"customer_id"`
	QuotationID          pgtype.Int8      `json:"quotation_id"`
	OrderDate            pgtype.Date      `json:"order_date"`
	ExpectedDeliveryDate pgtype.Date      `json:"expected_delivery_date"`
	Status               SalesOrderStatus `json:"status"`
	Currency             string           `json:"currency"`
	Subtotal             pgtype.Numeric   `json:"subtotal"`
	TaxAmount            pgtype.Numeric   `json:"tax_amount"`
	TotalAmount          pgtype.Numeric   `json:"total_amount"`
	Notes                pgtype.Text      `json:"notes"`
	CreatedBy            int64            `json:"created_by"`
}

func (q *Queries) CreateSalesOrder(ctx context.Context, arg CreateSalesOrderParams) (int64, error) {
	row := q.db.QueryRow(ctx, createSalesOrder,
		arg.DocNumber,
		arg.CompanyID,
		arg.CustomerID,
		arg.QuotationID,
		arg.OrderDate,
		arg.ExpectedDeliveryDate,
		arg.Status,
		arg.Currency,
		arg.Subtotal,
		arg.TaxAmount,
		arg.TotalAmount,
		arg.Notes,
		arg.CreatedBy,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteQuotationLines = `-- name: DeleteQuotationLines :exec
DELETE FROM quotation_lines WHERE quotation_id = $1
`

func (q *Queries) DeleteQuotationLines(ctx context.Context, quotationID int64) error {
	_, err := q.db.Exec(ctx, deleteQuotationLines, quotationID)
	return err
}

const deleteSalesOrderLines = `-- name: DeleteSalesOrderLines :exec
DELETE FROM sales_order_lines WHERE sales_order_id = $1
`

func (q *Queries) DeleteSalesOrderLines(ctx context.Context, salesOrderID int64) error {
	_, err := q.db.Exec(ctx, deleteSalesOrderLines, salesOrderID)
	return err
}

const getCustomer = `-- name: GetCustomer :one

SELECT id, code, name, company_id, email, phone, tax_id,
       credit_limit, payment_terms_days, address_line1, address_line2,
       city, state, postal_code, country, is_active, notes,
       created_by, created_at, updated_at
FROM customers
WHERE id = $1
`

// =============================================================================
// CUSTOMERS
// =============================================================================
func (q *Queries) GetCustomer(ctx context.Context, id int64) (Customer, error) {
	row := q.db.QueryRow(ctx, getCustomer, id)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.CompanyID,
		&i.Email,
		&i.Phone,
		&i.TaxID,
		&i.CreditLimit,
		&i.PaymentTermsDays,
		&i.AddressLine1,
		&i.AddressLine2,
		&i.City,
		&i.State,
		&i.PostalCode,
		&i.Country,
		&i.IsActive,
		&i.Notes,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCustomerByCode = `-- name: GetCustomerByCode :one
SELECT id, code, name, company_id, email, phone, tax_id,
       credit_limit, payment_terms_days, address_line1, address_line2,
       city, state, postal_code, country, is_active, notes,
       created_by, created_at, updated_at
FROM customers
WHERE company_id = $1 AND code = $2
`

type GetCustomerByCodeParams struct {
	CompanyID int64  `json:"company_id"`
	Code      string `json:"code"`
}

func (q *Queries) GetCustomerByCode(ctx context.Context, arg GetCustomerByCodeParams) (Customer, error) {
	row := q.db.QueryRow(ctx, getCustomerByCode, arg.CompanyID, arg.Code)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.CompanyID,
		&i.Email,
		&i.Phone,
		&i.TaxID,
		&i.CreditLimit,
		&i.PaymentTermsDays,
		&i.AddressLine1,
		&i.AddressLine2,
		&i.City,
		&i.State,
		&i.PostalCode,
		&i.Country,
		&i.IsActive,
		&i.Notes,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getQuotation = `-- name: GetQuotation :one

SELECT id, doc_number, company_id, customer_id, quote_date, valid_until,
       status, currency, subtotal, tax_amount, total_amount, notes,
       created_by, approved_by, approved_at, rejected_by, rejected_at,
       rejection_reason, created_at, updated_at
FROM quotations
WHERE id = $1
`

// =============================================================================
// QUOTATIONS
// =============================================================================
func (q *Queries) GetQuotation(ctx context.Context, id int64) (Quotation, error) {
	row := q.db.QueryRow(ctx, getQuotation, id)
	var i Quotation
	err := row.Scan(
		&i.ID,
		&i.DocNumber,
		&i.CompanyID,
		&i.CustomerID,
		&i.QuoteDate,
		&i.ValidUntil,
		&i.Status,
		&i.Currency,
		&i.Subtotal,
		&i.TaxAmount,
		&i.TotalAmount,
		&i.Notes,
		&i.CreatedBy,
		&i.ApprovedBy,
		&i.ApprovedAt,
		&i.RejectedBy,
		&i.RejectedAt,
		&i.RejectionReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getQuotationByDocNumber = `-- name: GetQuotationByDocNumber :one
SELECT id, doc_number, company_id, customer_id, quote_date, valid_until,
       status, currency, subtotal, tax_amount, total_amount, notes,
       created_by, approved_by, approved_at, rejected_by, rejected_at,
       rejection_reason, created_at, updated_at
FROM quotations
WHERE doc_number = $1
`

func (q *Queries) GetQuotationByDocNumber(ctx context.Context, docNumber string) (Quotation, error) {
	row := q.db.QueryRow(ctx, getQuotationByDocNumber, docNumber)
	var i Quotation
	err := row.Scan(
		&i.ID,
		&i.DocNumber,
		&i.CompanyID,
		&i.CustomerID,
		&i.QuoteDate,
		&i.ValidUntil,
		&i.Status,
		&i.Currency,
		&i.Subtotal,
		&i.TaxAmount,
		&i.TotalAmount,
		&i.Notes,
		&i.CreatedBy,
		&i.ApprovedBy,
		&i.ApprovedAt,
		&i.RejectedBy,
		&i.RejectedAt,
		&i.RejectionReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getQuotationLines = `-- name: GetQuotationLines :many
SELECT id, quotation_id, product_id, description, quantity, uom,
       unit_price, discount_percent, discount_amount, tax_percent,
       tax_amount, line_total, notes, line_order, created_at, updated_at
FROM quotation_lines
WHERE quotation_id = $1
ORDER BY line_order, id
`

func (q *Queries) GetQuotationLines(ctx context.Context, quotationID int64) ([]QuotationLine, error) {
	rows, err := q.db.Query(ctx, getQuotationLines, quotationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QuotationLine
	for rows.Next() {
		var i QuotationLine
		if err := rows.Scan(
			&i.ID,
			&i.QuotationID,
			&i.ProductID,
			&i.Description,
			&i.Quantity,
			&i.Uom,
			&i.UnitPrice,
			&i.DiscountPercent,
			&i.DiscountAmount,
			&i.TaxPercent,
			&i.TaxAmount,
			&i.LineTotal,
			&i.Notes,
			&i.LineOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSalesOrder = `-- name: GetSalesOrder :one

SELECT id, doc_number, company_id, customer_id, quotation_id, order_date,
       expected_delivery_date, status, currency, subtotal, tax_amount, total_amount,
       notes, created_by, confirmed_by, confirmed_at, cancelled_by, cancelled_at,
       cancellation_reason, created_at, updated_at
FROM sales_orders
WHERE id = $1
`

// =============================================================================
// SALES ORDERS
// =============================================================================
func (q *Queries) GetSalesOrder(ctx context.Context, id int64) (SalesOrder, error) {
	row := q.db.QueryRow(ctx, getSalesOrder, id)
	var i SalesOrder
	err := row.Scan(
		&i.ID,
		&i.DocNumber,
		&i.CompanyID,
		&i.CustomerID,
		&i.QuotationID,
		&i.OrderDate,
		&i.ExpectedDeliveryDate,
		&i.Status,
		&i.Currency,
		&i.Subtotal,
		&i.TaxAmount,
		&i.TotalAmount,
		&i.Notes,
		&i.CreatedBy,
		&i.ConfirmedBy,
		&i.ConfirmedAt,
		&i.CancelledBy,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSalesOrderByDocNumber = `-- name: GetSalesOrderByDocNumber :one
SELECT id, doc_number, company_id, customer_id, quotation_id, order_date,
       expected_delivery_date, status, currency, subtotal, tax_amount, total_amount,
       notes, created_by, confirmed_by, confirmed_at, cancelled_by, cancelled_at,
       cancellation_reason, created_at, updated_at
FROM sales_orders
WHERE doc_number = $1
`

func (q *Queries) GetSalesOrderByDocNumber(ctx context.Context, docNumber string) (SalesOrder, error) {
	row := q.db.QueryRow(ctx, getSalesOrderByDocNumber, docNumber)
	var i SalesOrder
	err := row.Scan(
		&i.ID,
		&i.DocNumber,
		&i.CompanyID,
		&i.CustomerID,
		&i.QuotationID,
		&i.OrderDate,
		&i.ExpectedDeliveryDate,
		&i.Status,
		&i.Currency,
		&i.Subtotal,
		&i.TaxAmount,
		&i.TotalAmount,
		&i.Notes,
		&i.CreatedBy,
		&i.ConfirmedBy,
		&i.ConfirmedAt,
		&i.CancelledBy,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSalesOrderLines = `-- name: GetSalesOrderLines :many
SELECT id, sales_order_id, product_id, description, quantity,
       quantity_delivered, quantity_invoiced, uom, unit_price,
       discount_percent, discount_amount, tax_percent, tax_amount,
       line_total, notes, line_order, created_at, updated_at
FROM sales_order_lines
WHERE sales_order_id = $1
ORDER BY line_order, id
`

func (q *Queries) GetSalesOrderLines(ctx context.Context, salesOrderID int64) ([]SalesOrderLine, error) {
	rows, err := q.db.Query(ctx, getSalesOrderLines, salesOrderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SalesOrderLine
	for rows.Next() {
		var i SalesOrderLine
		if err := rows.Scan(
			&i.ID,
			&i.SalesOrderID,
			&i.ProductID,
			&i.Description,
			&i.Quantity,
			&i.QuantityDelivered,
			&i.QuantityInvoiced,
			&i.Uom,
			&i.UnitPrice,
			&i.DiscountPercent,
			&i.DiscountAmount,
			&i.TaxPercent,
			&i.TaxAmount,
			&i.LineTotal,
			&i.Notes,
			&i.LineOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertQuotationLine = `-- name: InsertQuotationLine :one
INSERT INTO quotation_lines (
    quotation_id, product_id, description, quantity, uom,
    unit_price, discount_percent, discount_amount, tax_percent,
    tax_amount, line_total, notes, line_order
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
RETURNING id
`

type InsertQuotationLineParams struct {
	QuotationID     int64          `json:"quotation_id"`
	ProductID       int64          `json:"product_id"`
	Description     pgtype.Text    `json:"description"`
	Quantity        pgtype.Numeric `json:"quantity"`
	Uom             string         `json:"uom"`
	UnitPrice       pgtype.Numeric `json:"unit_price"`
	DiscountPercent pgtype.Numeric `json:"discount_percent"`
	DiscountAmount  pgtype.Numeric `json:"discount_amount"`
	TaxPercent      pgtype.Numeric `json:"tax_percent"`
	TaxAmount       pgtype.Numeric `json:"tax_amount"`
	LineTotal       pgtype.Numeric `json:"line_total"`
	Notes           pgtype.Text    `json:"notes"`
	LineOrder       int32          `json:"line_order"`
}

func (q *Queries) InsertQuotationLine(ctx context.Context, arg InsertQuotationLineParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertQuotationLine,
		arg.QuotationID,
		arg.ProductID,
		arg.Description,
		arg.Quantity,
		arg.Uom,
		arg.UnitPrice,
		arg.DiscountPercent,
		arg.DiscountAmount,
		arg.TaxPercent,
		arg.TaxAmount,
		arg.LineTotal,
		arg.Notes,
		arg.LineOrder,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertSalesOrderLine = `-- name: InsertSalesOrderLine :one
INSERT INTO sales_order_lines (
    sales_order_id, product_id, description, quantity,
    quantity_delivered, quantity_invoiced, uom, unit_price,
    discount_percent, discount_amount, tax_percent, tax_amount,
    line_total, notes, line_order
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
RETURNING id
`

type InsertSalesOrderLineParams struct {
	SalesOrderID      int64          `json:"sales_order_id"`
	ProductID         int64          `json:"product_id"`
	Description       pgtype.Text    `json:"description"`
	Quantity          pgtype.Numeric `json:"quantity"`
	QuantityDelivered pgtype.Numeric `json:"quantity_delivered"`
	QuantityInvoiced  pgtype.Numeric `json:"quantity_invoiced"`
	Uom               string         `json:"uom"`
	UnitPrice         pgtype.Numeric `json:"unit_price"`
	DiscountPercent   pgtype.Numeric `json:"discount_percent"`
	DiscountAmount    pgtype.Numeric `json:"discount_amount"`
	TaxPercent        pgtype.Numeric `json:"tax_percent"`
	TaxAmount         pgtype.Numeric `json:"tax_amount"`
	LineTotal         pgtype.Numeric `json:"line_total"`
	Notes             pgtype.Text    `json:"notes"`
	LineOrder         int32          `json:"line_order"`
}

func (q *Queries) InsertSalesOrderLine(ctx context.Context, arg InsertSalesOrderLineParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertSalesOrderLine,
		arg.SalesOrderID,
		arg.ProductID,
		arg.Description,
		arg.Quantity,
		arg.QuantityDelivered,
		arg.QuantityInvoiced,
		arg.Uom,
		arg.UnitPrice,
		arg.DiscountPercent,
		arg.DiscountAmount,
		arg.TaxPercent,
		arg.TaxAmount,
		arg.LineTotal,
		arg.Notes,
		arg.LineOrder,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateCustomer = `-- name: UpdateCustomer :exec
UPDATE customers SET 
    name = COALESCE($1, name),
    email = COALESCE($2, email),
    phone = COALESCE($3, phone),
    address_line1 = COALESCE($4, address_line1),
    address_line2 = COALESCE($5, address_line2),
    city = COALESCE($6, city),
    state = COALESCE($7, state),
    postal_code = COALESCE($8, postal_code),
    country = COALESCE($9, country),
    is_active = COALESCE($10, is_active),
    notes = COALESCE($11, notes),
    updated_at = NOW()
WHERE id = $12
`

type UpdateCustomerParams struct {
	Name         pgtype.Text `json:"name"`
	Email        pgtype.Text `json:"email"`
	Phone        pgtype.Text `json:"phone"`
	AddressLine1 pgtype.Text `json:"address_line1"`
	AddressLine2 pgtype.Text `json:"address_line2"`
	City         pgtype.Text `json:"city"`
	State        pgtype.Text `json:"state"`
	PostalCode   pgtype.Text `json:"postal_code"`
	Country      pgtype.Text `json:"country"`
	IsActive     pgtype.Bool `json:"is_active"`
	Notes        pgtype.Text `json:"notes"`
	ID           int64       `json:"id"`
}

func (q *Queries) UpdateCustomer(ctx context.Context, arg UpdateCustomerParams) error {
	_, err := q.db.Exec(ctx, updateCustomer,
		arg.Name,
		arg.Email,
		arg.Phone,
		arg.AddressLine1,
		arg.AddressLine2,
		arg.City,
		arg.State,
		arg.PostalCode,
		arg.Country,
		arg.IsActive,
		arg.Notes,
		arg.ID,
	)
	return err
}

const updateQuotationStatus = `-- name: UpdateQuotationStatus :exec
UPDATE quotations SET 
    status = $1, 
    approved_by = $3,
    approved_at = $4,
    rejected_by = $5,
    rejected_at = $6,
    rejection_reason = $7,
    updated_at = NOW()
WHERE id = $2
`

type UpdateQuotationStatusParams struct {
	Status          QuotationStatus    `json:"status"`
	ID              int64              `json:"id"`
	ApprovedBy      pgtype.Int8        `json:"approved_by"`
	ApprovedAt      pgtype.Timestamptz `json:"approved_at"`
	RejectedBy      pgtype.Int8        `json:"rejected_by"`
	RejectedAt      pgtype.Timestamptz `json:"rejected_at"`
	RejectionReason pgtype.Text        `json:"rejection_reason"`
}

func (q *Queries) UpdateQuotationStatus(ctx context.Context, arg UpdateQuotationStatusParams) error {
	_, err := q.db.Exec(ctx, updateQuotationStatus,
		arg.Status,
		arg.ID,
		arg.ApprovedBy,
		arg.ApprovedAt,
		arg.RejectedBy,
		arg.RejectedAt,
		arg.RejectionReason,
	)
	return err
}

const updateSalesOrderLineDelivered = `-- name: UpdateSalesOrderLineDelivered :exec
UPDATE sales_order_lines SET quantity_delivered = $1, updated_at = NOW() WHERE id = $2
`

type UpdateSalesOrderLineDeliveredParams struct {
	QuantityDelivered pgtype.Numeric `json:"quantity_delivered"`
	ID                int64          `json:"id"`
}

func (q *Queries) UpdateSalesOrderLineDelivered(ctx context.Context, arg UpdateSalesOrderLineDeliveredParams) error {
	_, err := q.db.Exec(ctx, updateSalesOrderLineDelivered, arg.QuantityDelivered, arg.ID)
	return err
}

const updateSalesOrderStatus = `-- name: UpdateSalesOrderStatus :exec
UPDATE sales_orders SET 
    status = $1, 
    confirmed_by = $3,
    confirmed_at = $4,
    cancelled_by = $5,
    cancelled_at = $6,
    cancellation_reason = $7,
    updated_at = NOW()
WHERE id = $2
`

type UpdateSalesOrderStatusParams struct {
	Status             SalesOrderStatus   `json:"status"`
	ID                 int64              `json:"id"`
	ConfirmedBy        pgtype.Int8        `json:"confirmed_by"`
	ConfirmedAt        pgtype.Timestamptz `json:"confirmed_at"`
	CancelledBy        pgtype.Int8        `json:"cancelled_by"`
	CancelledAt        pgtype.Timestamptz `json:"cancelled_at"`
	CancellationReason pgtype.Text        `json:"cancellation_reason"`
}

func (q *Queries) UpdateSalesOrderStatus(ctx context.Context, arg UpdateSalesOrderStatusParams) error {
	_, err := q.db.Exec(ctx, updateSalesOrderStatus,
		arg.Status,
		arg.ID,
		arg.ConfirmedBy,
		arg.ConfirmedAt,
		arg.CancelledBy,
		arg.CancelledAt,
		arg.CancellationReason,
	)
	return err
}
