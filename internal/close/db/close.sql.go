// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: close.sql

package closedb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countPendingChecklistItems = `-- name: CountPendingChecklistItems :one
SELECT COUNT(*) 
FROM period_close_checklist_items
WHERE period_close_run_id = $1 AND status NOT IN ('DONE','SKIPPED')
`

func (q *Queries) CountPendingChecklistItems(ctx context.Context, periodCloseRunID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countPendingChecklistItems, periodCloseRunID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const insertAccountingPeriod = `-- name: InsertAccountingPeriod :one
INSERT INTO accounting_periods (period_id, company_id, name, start_date, end_date, status, metadata, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id
`

type InsertAccountingPeriodParams struct {
	PeriodID  int64                  `json:"period_id"`
	CompanyID pgtype.Int8            `json:"company_id"`
	Name      string                 `json:"name"`
	StartDate pgtype.Date            `json:"start_date"`
	EndDate   pgtype.Date            `json:"end_date"`
	Status    AccountingPeriodStatus `json:"status"`
	Metadata  []byte                 `json:"metadata"`
	CreatedAt pgtype.Timestamptz     `json:"created_at"`
	UpdatedAt pgtype.Timestamptz     `json:"updated_at"`
}

func (q *Queries) InsertAccountingPeriod(ctx context.Context, arg InsertAccountingPeriodParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertAccountingPeriod,
		arg.PeriodID,
		arg.CompanyID,
		arg.Name,
		arg.StartDate,
		arg.EndDate,
		arg.Status,
		arg.Metadata,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertChecklistItem = `-- name: InsertChecklistItem :one
INSERT INTO period_close_checklist_items (period_close_run_id, code, label)
VALUES ($1, $2, $3)
RETURNING id, period_close_run_id, code, label, status, assigned_to, completed_at, comment, created_at, updated_at
`

type InsertChecklistItemParams struct {
	PeriodCloseRunID int64  `json:"period_close_run_id"`
	Code             string `json:"code"`
	Label            string `json:"label"`
}

func (q *Queries) InsertChecklistItem(ctx context.Context, arg InsertChecklistItemParams) (PeriodCloseChecklistItem, error) {
	row := q.db.QueryRow(ctx, insertChecklistItem, arg.PeriodCloseRunID, arg.Code, arg.Label)
	var i PeriodCloseChecklistItem
	err := row.Scan(
		&i.ID,
		&i.PeriodCloseRunID,
		&i.Code,
		&i.Label,
		&i.Status,
		&i.AssignedTo,
		&i.CompletedAt,
		&i.Comment,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertCloseRun = `-- name: InsertCloseRun :one
INSERT INTO period_close_runs (company_id, period_id, status, created_by, notes)
VALUES ($1, $2, 'IN_PROGRESS', $3, $4)
RETURNING id, company_id, period_id, status, created_by, created_at, completed_at, notes
`

type InsertCloseRunParams struct {
	CompanyID int64       `json:"company_id"`
	PeriodID  int64       `json:"period_id"`
	CreatedBy int64       `json:"created_by"`
	Notes     pgtype.Text `json:"notes"`
}

type InsertCloseRunRow struct {
	ID          int64                `json:"id"`
	CompanyID   int64                `json:"company_id"`
	PeriodID    int64                `json:"period_id"`
	Status      PeriodCloseRunStatus `json:"status"`
	CreatedBy   int64                `json:"created_by"`
	CreatedAt   pgtype.Timestamptz   `json:"created_at"`
	CompletedAt pgtype.Timestamptz   `json:"completed_at"`
	Notes       pgtype.Text          `json:"notes"`
}

func (q *Queries) InsertCloseRun(ctx context.Context, arg InsertCloseRunParams) (InsertCloseRunRow, error) {
	row := q.db.QueryRow(ctx, insertCloseRun,
		arg.CompanyID,
		arg.PeriodID,
		arg.CreatedBy,
		arg.Notes,
	)
	var i InsertCloseRunRow
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.PeriodID,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.CompletedAt,
		&i.Notes,
	)
	return i, err
}

const insertPeriodLegacy = `-- name: InsertPeriodLegacy :one
INSERT INTO periods (code, start_date, end_date, status)
VALUES ($1, $2, $3, $4)
RETURNING id, created_at, updated_at
`

type InsertPeriodLegacyParams struct {
	Code      string       `json:"code"`
	StartDate pgtype.Date  `json:"start_date"`
	EndDate   pgtype.Date  `json:"end_date"`
	Status    PeriodStatus `json:"status"`
}

type InsertPeriodLegacyRow struct {
	ID        int64              `json:"id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) InsertPeriodLegacy(ctx context.Context, arg InsertPeriodLegacyParams) (InsertPeriodLegacyRow, error) {
	row := q.db.QueryRow(ctx, insertPeriodLegacy,
		arg.Code,
		arg.StartDate,
		arg.EndDate,
		arg.Status,
	)
	var i InsertPeriodLegacyRow
	err := row.Scan(&i.ID, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const listChecklistItems = `-- name: ListChecklistItems :many
SELECT id, period_close_run_id, code, label, status, assigned_to, completed_at, comment, created_at, updated_at
FROM period_close_checklist_items
WHERE period_close_run_id = $1
ORDER BY id
`

func (q *Queries) ListChecklistItems(ctx context.Context, periodCloseRunID int64) ([]PeriodCloseChecklistItem, error) {
	rows, err := q.db.Query(ctx, listChecklistItems, periodCloseRunID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PeriodCloseChecklistItem
	for rows.Next() {
		var i PeriodCloseChecklistItem
		if err := rows.Scan(
			&i.ID,
			&i.PeriodCloseRunID,
			&i.Code,
			&i.Label,
			&i.Status,
			&i.AssignedTo,
			&i.CompletedAt,
			&i.Comment,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPeriods = `-- name: ListPeriods :many
SELECT ap.id, ap.period_id, COALESCE(ap.company_id, 0), ap.name, ap.start_date, ap.end_date, ap.status,
       ap.soft_closed_by, ap.soft_closed_at, ap.closed_by, ap.closed_at, ap.metadata, ap.created_at, ap.updated_at,
       lr.id AS latest_run_id
FROM accounting_periods ap
LEFT JOIN LATERAL (
    SELECT id
    FROM period_close_runs r
    WHERE r.period_id = ap.id
    ORDER BY r.created_at DESC
    LIMIT 1
) lr ON TRUE
WHERE ($1 = 0 OR company_id = $1)
ORDER BY start_date DESC
LIMIT $2 OFFSET $3
`

type ListPeriodsParams struct {
	Column1 interface{} `json:"column_1"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type ListPeriodsRow struct {
	ID           int64                  `json:"id"`
	PeriodID     int64                  `json:"period_id"`
	CompanyID    int64                  `json:"company_id"`
	Name         string                 `json:"name"`
	StartDate    pgtype.Date            `json:"start_date"`
	EndDate      pgtype.Date            `json:"end_date"`
	Status       AccountingPeriodStatus `json:"status"`
	SoftClosedBy pgtype.Int8            `json:"soft_closed_by"`
	SoftClosedAt pgtype.Timestamptz     `json:"soft_closed_at"`
	ClosedBy     pgtype.Int8            `json:"closed_by"`
	ClosedAt     pgtype.Timestamptz     `json:"closed_at"`
	Metadata     []byte                 `json:"metadata"`
	CreatedAt    pgtype.Timestamptz     `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz     `json:"updated_at"`
	LatestRunID  int64                  `json:"latest_run_id"`
}

func (q *Queries) ListPeriods(ctx context.Context, arg ListPeriodsParams) ([]ListPeriodsRow, error) {
	rows, err := q.db.Query(ctx, listPeriods, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPeriodsRow
	for rows.Next() {
		var i ListPeriodsRow
		if err := rows.Scan(
			&i.ID,
			&i.PeriodID,
			&i.CompanyID,
			&i.Name,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.SoftClosedBy,
			&i.SoftClosedAt,
			&i.ClosedBy,
			&i.ClosedAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LatestRunID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const loadCloseRun = `-- name: LoadCloseRun :one
SELECT id, company_id, period_id, status, created_by, created_at, completed_at, notes
FROM period_close_runs WHERE id = $1
`

type LoadCloseRunRow struct {
	ID          int64                `json:"id"`
	CompanyID   int64                `json:"company_id"`
	PeriodID    int64                `json:"period_id"`
	Status      PeriodCloseRunStatus `json:"status"`
	CreatedBy   int64                `json:"created_by"`
	CreatedAt   pgtype.Timestamptz   `json:"created_at"`
	CompletedAt pgtype.Timestamptz   `json:"completed_at"`
	Notes       pgtype.Text          `json:"notes"`
}

func (q *Queries) LoadCloseRun(ctx context.Context, id int64) (LoadCloseRunRow, error) {
	row := q.db.QueryRow(ctx, loadCloseRun, id)
	var i LoadCloseRunRow
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.PeriodID,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.CompletedAt,
		&i.Notes,
	)
	return i, err
}

const loadCloseRunForUpdate = `-- name: LoadCloseRunForUpdate :one
SELECT id, company_id, period_id, status, created_by, created_at, completed_at, notes
FROM period_close_runs WHERE id = $1 FOR UPDATE
`

type LoadCloseRunForUpdateRow struct {
	ID          int64                `json:"id"`
	CompanyID   int64                `json:"company_id"`
	PeriodID    int64                `json:"period_id"`
	Status      PeriodCloseRunStatus `json:"status"`
	CreatedBy   int64                `json:"created_by"`
	CreatedAt   pgtype.Timestamptz   `json:"created_at"`
	CompletedAt pgtype.Timestamptz   `json:"completed_at"`
	Notes       pgtype.Text          `json:"notes"`
}

func (q *Queries) LoadCloseRunForUpdate(ctx context.Context, id int64) (LoadCloseRunForUpdateRow, error) {
	row := q.db.QueryRow(ctx, loadCloseRunForUpdate, id)
	var i LoadCloseRunForUpdateRow
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.PeriodID,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.CompletedAt,
		&i.Notes,
	)
	return i, err
}

const loadPeriod = `-- name: LoadPeriod :one
SELECT ap.id, ap.period_id, COALESCE(ap.company_id, 0), ap.name, ap.start_date, ap.end_date, ap.status,
       ap.soft_closed_by, ap.soft_closed_at, ap.closed_by, ap.closed_at, ap.metadata, ap.created_at, ap.updated_at,
       lr.id AS latest_run_id
FROM accounting_periods ap
LEFT JOIN LATERAL (
    SELECT id
    FROM period_close_runs r
    WHERE r.period_id = ap.id
    ORDER BY r.created_at DESC
    LIMIT 1
) lr ON TRUE
WHERE ap.id = $1
`

type LoadPeriodRow struct {
	ID           int64                  `json:"id"`
	PeriodID     int64                  `json:"period_id"`
	CompanyID    int64                  `json:"company_id"`
	Name         string                 `json:"name"`
	StartDate    pgtype.Date            `json:"start_date"`
	EndDate      pgtype.Date            `json:"end_date"`
	Status       AccountingPeriodStatus `json:"status"`
	SoftClosedBy pgtype.Int8            `json:"soft_closed_by"`
	SoftClosedAt pgtype.Timestamptz     `json:"soft_closed_at"`
	ClosedBy     pgtype.Int8            `json:"closed_by"`
	ClosedAt     pgtype.Timestamptz     `json:"closed_at"`
	Metadata     []byte                 `json:"metadata"`
	CreatedAt    pgtype.Timestamptz     `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz     `json:"updated_at"`
	LatestRunID  int64                  `json:"latest_run_id"`
}

func (q *Queries) LoadPeriod(ctx context.Context, id int64) (LoadPeriodRow, error) {
	row := q.db.QueryRow(ctx, loadPeriod, id)
	var i LoadPeriodRow
	err := row.Scan(
		&i.ID,
		&i.PeriodID,
		&i.CompanyID,
		&i.Name,
		&i.StartDate,
		&i.EndDate,
		&i.Status,
		&i.SoftClosedBy,
		&i.SoftClosedAt,
		&i.ClosedBy,
		&i.ClosedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LatestRunID,
	)
	return i, err
}

const loadPeriodByLedgerID = `-- name: LoadPeriodByLedgerID :one
SELECT ap.id, ap.period_id, COALESCE(ap.company_id, 0), ap.name, ap.start_date, ap.end_date, ap.status,
       ap.soft_closed_by, ap.soft_closed_at, ap.closed_by, ap.closed_at, ap.metadata, ap.created_at, ap.updated_at,
       lr.id AS latest_run_id
FROM accounting_periods ap
LEFT JOIN LATERAL (
    SELECT id
    FROM period_close_runs r
    WHERE r.period_id = ap.id
    ORDER BY r.created_at DESC
    LIMIT 1
) lr ON TRUE
WHERE ap.period_id = $1
`

type LoadPeriodByLedgerIDRow struct {
	ID           int64                  `json:"id"`
	PeriodID     int64                  `json:"period_id"`
	CompanyID    int64                  `json:"company_id"`
	Name         string                 `json:"name"`
	StartDate    pgtype.Date            `json:"start_date"`
	EndDate      pgtype.Date            `json:"end_date"`
	Status       AccountingPeriodStatus `json:"status"`
	SoftClosedBy pgtype.Int8            `json:"soft_closed_by"`
	SoftClosedAt pgtype.Timestamptz     `json:"soft_closed_at"`
	ClosedBy     pgtype.Int8            `json:"closed_by"`
	ClosedAt     pgtype.Timestamptz     `json:"closed_at"`
	Metadata     []byte                 `json:"metadata"`
	CreatedAt    pgtype.Timestamptz     `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz     `json:"updated_at"`
	LatestRunID  int64                  `json:"latest_run_id"`
}

func (q *Queries) LoadPeriodByLedgerID(ctx context.Context, periodID int64) (LoadPeriodByLedgerIDRow, error) {
	row := q.db.QueryRow(ctx, loadPeriodByLedgerID, periodID)
	var i LoadPeriodByLedgerIDRow
	err := row.Scan(
		&i.ID,
		&i.PeriodID,
		&i.CompanyID,
		&i.Name,
		&i.StartDate,
		&i.EndDate,
		&i.Status,
		&i.SoftClosedBy,
		&i.SoftClosedAt,
		&i.ClosedBy,
		&i.ClosedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LatestRunID,
	)
	return i, err
}

const loadPeriodForUpdate = `-- name: LoadPeriodForUpdate :one
SELECT ap.id, ap.period_id, COALESCE(ap.company_id, 0), ap.name, ap.start_date, ap.end_date, ap.status,
       ap.soft_closed_by, ap.soft_closed_at, ap.closed_by, ap.closed_at, ap.metadata, ap.created_at, ap.updated_at,
       lr.id AS latest_run_id
FROM accounting_periods ap
LEFT JOIN LATERAL (
    SELECT id
    FROM period_close_runs r
    WHERE r.period_id = ap.id
    ORDER BY r.created_at DESC
    LIMIT 1
) lr ON TRUE
WHERE ap.id = $1
FOR UPDATE
`

type LoadPeriodForUpdateRow struct {
	ID           int64                  `json:"id"`
	PeriodID     int64                  `json:"period_id"`
	CompanyID    int64                  `json:"company_id"`
	Name         string                 `json:"name"`
	StartDate    pgtype.Date            `json:"start_date"`
	EndDate      pgtype.Date            `json:"end_date"`
	Status       AccountingPeriodStatus `json:"status"`
	SoftClosedBy pgtype.Int8            `json:"soft_closed_by"`
	SoftClosedAt pgtype.Timestamptz     `json:"soft_closed_at"`
	ClosedBy     pgtype.Int8            `json:"closed_by"`
	ClosedAt     pgtype.Timestamptz     `json:"closed_at"`
	Metadata     []byte                 `json:"metadata"`
	CreatedAt    pgtype.Timestamptz     `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz     `json:"updated_at"`
	LatestRunID  int64                  `json:"latest_run_id"`
}

func (q *Queries) LoadPeriodForUpdate(ctx context.Context, id int64) (LoadPeriodForUpdateRow, error) {
	row := q.db.QueryRow(ctx, loadPeriodForUpdate, id)
	var i LoadPeriodForUpdateRow
	err := row.Scan(
		&i.ID,
		&i.PeriodID,
		&i.CompanyID,
		&i.Name,
		&i.StartDate,
		&i.EndDate,
		&i.Status,
		&i.SoftClosedBy,
		&i.SoftClosedAt,
		&i.ClosedBy,
		&i.ClosedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LatestRunID,
	)
	return i, err
}

const lockChecklistItemRun = `-- name: LockChecklistItemRun :one
SELECT period_close_run_id FROM period_close_checklist_items WHERE id = $1 FOR UPDATE
`

func (q *Queries) LockChecklistItemRun(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRow(ctx, lockChecklistItemRun, id)
	var period_close_run_id int64
	err := row.Scan(&period_close_run_id)
	return period_close_run_id, err
}

const periodHasActiveRun = `-- name: PeriodHasActiveRun :one
SELECT 1 FROM period_close_runs
WHERE period_id = $1 AND status IN ('DRAFT','IN_PROGRESS')
LIMIT 1
`

func (q *Queries) PeriodHasActiveRun(ctx context.Context, periodID int64) (int32, error) {
	row := q.db.QueryRow(ctx, periodHasActiveRun, periodID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const periodRangeConflict = `-- name: PeriodRangeConflict :one
SELECT 1
FROM accounting_periods
WHERE company_id = $1
  AND daterange(start_date, end_date, '[]') && daterange($2, $3, '[]')
LIMIT 1
`

type PeriodRangeConflictParams struct {
	CompanyID   pgtype.Int8 `json:"company_id"`
	Daterange   pgtype.Date `json:"daterange"`
	Daterange_2 pgtype.Date `json:"daterange_2"`
}

func (q *Queries) PeriodRangeConflict(ctx context.Context, arg PeriodRangeConflictParams) (int32, error) {
	row := q.db.QueryRow(ctx, periodRangeConflict, arg.CompanyID, arg.Daterange, arg.Daterange_2)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const updateAccountingPeriodStatus = `-- name: UpdateAccountingPeriodStatus :exec
UPDATE accounting_periods
SET status = $2,
    soft_closed_by = CASE
        WHEN $2 = 'SOFT_CLOSED' THEN $3
        WHEN $2 = 'OPEN' THEN NULL
        ELSE soft_closed_by
    END,
    soft_closed_at = CASE
        WHEN $2 = 'SOFT_CLOSED' THEN NOW()
        WHEN $2 = 'OPEN' THEN NULL
        ELSE soft_closed_at
    END,
    closed_by = CASE
        WHEN $2 = 'HARD_CLOSED' THEN $3
        WHEN $2 != 'HARD_CLOSED' THEN NULL
        ELSE closed_by
    END,
    closed_at = CASE
        WHEN $2 = 'HARD_CLOSED' THEN NOW()
        WHEN $2 != 'HARD_CLOSED' THEN NULL
        ELSE closed_at
    END,
    updated_at = NOW()
WHERE id = $1
`

type UpdateAccountingPeriodStatusParams struct {
	ID           int64                  `json:"id"`
	Status       AccountingPeriodStatus `json:"status"`
	SoftClosedBy pgtype.Int8            `json:"soft_closed_by"`
}

func (q *Queries) UpdateAccountingPeriodStatus(ctx context.Context, arg UpdateAccountingPeriodStatusParams) error {
	_, err := q.db.Exec(ctx, updateAccountingPeriodStatus, arg.ID, arg.Status, arg.SoftClosedBy)
	return err
}

const updateChecklistStatus = `-- name: UpdateChecklistStatus :one
UPDATE period_close_checklist_items
SET status = $2,
    comment = COALESCE(NULLIF($3,''), comment),
    completed_at = CASE WHEN $2 IN ('DONE','SKIPPED') THEN NOW() ELSE NULL END,
    updated_at = NOW()
WHERE id = $1
RETURNING id, period_close_run_id, code, label, status, assigned_to, completed_at, comment, created_at, updated_at
`

type UpdateChecklistStatusParams struct {
	ID      int64                      `json:"id"`
	Status  PeriodCloseChecklistStatus `json:"status"`
	Column3 interface{}                `json:"column_3"`
}

func (q *Queries) UpdateChecklistStatus(ctx context.Context, arg UpdateChecklistStatusParams) (PeriodCloseChecklistItem, error) {
	row := q.db.QueryRow(ctx, updateChecklistStatus, arg.ID, arg.Status, arg.Column3)
	var i PeriodCloseChecklistItem
	err := row.Scan(
		&i.ID,
		&i.PeriodCloseRunID,
		&i.Code,
		&i.Label,
		&i.Status,
		&i.AssignedTo,
		&i.CompletedAt,
		&i.Comment,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLegacyPeriodStatus = `-- name: UpdateLegacyPeriodStatus :exec
UPDATE periods 
SET status = $2, updated_at = NOW() 
WHERE id = (SELECT period_id FROM accounting_periods WHERE accounting_periods.id = $1)
`

type UpdateLegacyPeriodStatusParams struct {
	ID     int64        `json:"id"`
	Status PeriodStatus `json:"status"`
}

func (q *Queries) UpdateLegacyPeriodStatus(ctx context.Context, arg UpdateLegacyPeriodStatusParams) error {
	_, err := q.db.Exec(ctx, updateLegacyPeriodStatus, arg.ID, arg.Status)
	return err
}

const updateRunStatus = `-- name: UpdateRunStatus :exec
UPDATE period_close_runs
SET status = $2,
    completed_at = CASE WHEN $2 = 'COMPLETED' THEN NOW() ELSE completed_at END,
    updated_at = NOW()
WHERE id = $1
`

type UpdateRunStatusParams struct {
	ID     int64                `json:"id"`
	Status PeriodCloseRunStatus `json:"status"`
}

func (q *Queries) UpdateRunStatus(ctx context.Context, arg UpdateRunStatusParams) error {
	_, err := q.db.Exec(ctx, updateRunStatus, arg.ID, arg.Status)
	return err
}
