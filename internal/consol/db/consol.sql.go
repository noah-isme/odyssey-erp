// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: consol.sql

package consoldb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const activeConsolidationPeriod = `-- name: ActiveConsolidationPeriod :one
SELECT code FROM periods WHERE status = 'OPEN_CONSOL' ORDER BY start_date DESC LIMIT 1
`

func (q *Queries) ActiveConsolidationPeriod(ctx context.Context) (string, error) {
	row := q.db.QueryRow(ctx, activeConsolidationPeriod)
	var code string
	err := row.Scan(&code)
	return code, err
}

const balances = `-- name: Balances :many
SELECT mv.group_account_id,
       ga.code,
       ga.name,
       mv.local_ccy_amt,
       mv.group_ccy_amt,
       mv.members
FROM mv_consol_balances mv
JOIN consol_group_accounts ga ON ga.id = mv.group_account_id
WHERE mv.group_id = $1 AND mv.period_id = $2
ORDER BY ga.code
`

type BalancesParams struct {
	GroupID  int64 `json:"group_id"`
	PeriodID int64 `json:"period_id"`
}

type BalancesRow struct {
	GroupAccountID int64  `json:"group_account_id"`
	Code           string `json:"code"`
	Name           string `json:"name"`
	LocalCcyAmt    int64  `json:"local_ccy_amt"`
	GroupCcyAmt    int64  `json:"group_ccy_amt"`
	Members        []byte `json:"members"`
}

func (q *Queries) Balances(ctx context.Context, arg BalancesParams) ([]BalancesRow, error) {
	rows, err := q.db.Query(ctx, balances, arg.GroupID, arg.PeriodID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BalancesRow
	for rows.Next() {
		var i BalancesRow
		if err := rows.Scan(
			&i.GroupAccountID,
			&i.Code,
			&i.Name,
			&i.LocalCcyAmt,
			&i.GroupCcyAmt,
			&i.Members,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const calculateConsolBalances = `-- name: CalculateConsolBalances :exec
INSERT INTO mv_consol_balances (period_id, group_id, group_account_id, local_ccy_amt, group_ccy_amt, members)
SELECT $1 AS period_id,
       $2 AS group_id,
       base.group_account_id,
       SUM(base.local_amt) AS local_ccy_amt,
       SUM(base.local_amt) AS group_ccy_amt,
       jsonb_agg(
           jsonb_build_object(
               'company_id', base.company_id,
               'company_name', base.company_name,
               'local_ccy_amt', base.local_amt
           ) ORDER BY base.company_id
       ) AS members
FROM (
    SELECT
        je.period_id,
        cm.group_id,
        am.group_account_id,
        cm.company_id,
        c.name AS company_name,
        SUM(jl.debit - jl.credit) AS local_amt
    FROM journal_lines jl
    JOIN journal_entries je ON je.id = jl.je_id AND je.status = 'POSTED' AND je.period_id = $1
    JOIN consol_members cm ON cm.company_id = jl.dim_company_id AND cm.group_id = $2 AND cm.enabled
    JOIN companies c ON c.id = cm.company_id
    JOIN account_map am ON am.group_id = cm.group_id AND am.company_id = cm.company_id AND am.local_account_id = jl.account_id
    GROUP BY je.period_id, cm.group_id, am.group_account_id, cm.company_id, c.name
) AS base
GROUP BY base.group_account_id
`

type CalculateConsolBalancesParams struct {
	PeriodID int64 `json:"period_id"`
	GroupID  int64 `json:"group_id"`
}

func (q *Queries) CalculateConsolBalances(ctx context.Context, arg CalculateConsolBalancesParams) error {
	_, err := q.db.Exec(ctx, calculateConsolBalances, arg.PeriodID, arg.GroupID)
	return err
}

const consolBalancesByType = `-- name: ConsolBalancesByType :many
SELECT
    mv.group_account_id,
    ga.code,
    ga.name,
    ga.type,
    mv.local_ccy_amt,
    mv.group_ccy_amt,
    mv.members
FROM mv_consol_balances mv
JOIN consol_group_accounts ga ON ga.id = mv.group_account_id
WHERE mv.group_id = $1 AND mv.period_id = $2
ORDER BY ga.code
`

type ConsolBalancesByTypeParams struct {
	GroupID  int64 `json:"group_id"`
	PeriodID int64 `json:"period_id"`
}

type ConsolBalancesByTypeRow struct {
	GroupAccountID int64       `json:"group_account_id"`
	Code           string      `json:"code"`
	Name           string      `json:"name"`
	Type           AccountType `json:"type"`
	LocalCcyAmt    int64       `json:"local_ccy_amt"`
	GroupCcyAmt    int64       `json:"group_ccy_amt"`
	Members        []byte      `json:"members"`
}

func (q *Queries) ConsolBalancesByType(ctx context.Context, arg ConsolBalancesByTypeParams) ([]ConsolBalancesByTypeRow, error) {
	rows, err := q.db.Query(ctx, consolBalancesByType, arg.GroupID, arg.PeriodID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ConsolBalancesByTypeRow
	for rows.Next() {
		var i ConsolBalancesByTypeRow
		if err := rows.Scan(
			&i.GroupAccountID,
			&i.Code,
			&i.Name,
			&i.Type,
			&i.LocalCcyAmt,
			&i.GroupCcyAmt,
			&i.Members,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteConsolBalances = `-- name: DeleteConsolBalances :exec
DELETE FROM mv_consol_balances WHERE period_id = $1 AND group_id = $2
`

type DeleteConsolBalancesParams struct {
	PeriodID int64 `json:"period_id"`
	GroupID  int64 `json:"group_id"`
}

func (q *Queries) DeleteConsolBalances(ctx context.Context, arg DeleteConsolBalancesParams) error {
	_, err := q.db.Exec(ctx, deleteConsolBalances, arg.PeriodID, arg.GroupID)
	return err
}

const findPeriodID = `-- name: FindPeriodID :one
SELECT id FROM periods WHERE code = $1
`

func (q *Queries) FindPeriodID(ctx context.Context, code string) (int64, error) {
	row := q.db.QueryRow(ctx, findPeriodID, code)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const fxRateForPeriod = `-- name: FxRateForPeriod :one
SELECT average_rate, closing_rate FROM fx_rates WHERE as_of_date = $1 AND pair = $2 LIMIT 1
`

type FxRateForPeriodParams struct {
	AsOfDate pgtype.Date `json:"as_of_date"`
	Pair     string      `json:"pair"`
}

type FxRateForPeriodRow struct {
	AverageRate pgtype.Numeric `json:"average_rate"`
	ClosingRate pgtype.Numeric `json:"closing_rate"`
}

func (q *Queries) FxRateForPeriod(ctx context.Context, arg FxRateForPeriodParams) (FxRateForPeriodRow, error) {
	row := q.db.QueryRow(ctx, fxRateForPeriod, arg.AsOfDate, arg.Pair)
	var i FxRateForPeriodRow
	err := row.Scan(&i.AverageRate, &i.ClosingRate)
	return i, err
}

const getGroup = `-- name: GetGroup :one
SELECT name, reporting_currency FROM consol_groups WHERE id = $1
`

type GetGroupRow struct {
	Name              string `json:"name"`
	ReportingCurrency string `json:"reporting_currency"`
}

func (q *Queries) GetGroup(ctx context.Context, id int64) (GetGroupRow, error) {
	row := q.db.QueryRow(ctx, getGroup, id)
	var i GetGroupRow
	err := row.Scan(&i.Name, &i.ReportingCurrency)
	return i, err
}

const listGroupIDs = `-- name: ListGroupIDs :many
SELECT id FROM consol_groups ORDER BY id
`

func (q *Queries) ListGroupIDs(ctx context.Context) ([]int64, error) {
	rows, err := q.db.Query(ctx, listGroupIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const memberCurrencies = `-- name: MemberCurrencies :many
SELECT cm.company_id, 'IDR'::text as currency
FROM consol_members cm
JOIN companies c ON c.id = cm.company_id
WHERE cm.group_id = $1
`

type MemberCurrenciesRow struct {
	CompanyID int64  `json:"company_id"`
	Currency  string `json:"currency"`
}

func (q *Queries) MemberCurrencies(ctx context.Context, groupID int64) ([]MemberCurrenciesRow, error) {
	rows, err := q.db.Query(ctx, memberCurrencies, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MemberCurrenciesRow
	for rows.Next() {
		var i MemberCurrenciesRow
		if err := rows.Scan(&i.CompanyID, &i.Currency); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const members = `-- name: Members :many
SELECT cm.company_id, c.name, cm.enabled
FROM consol_members cm
JOIN companies c ON c.id = cm.company_id
WHERE cm.group_id = $1
ORDER BY c.name
`

type MembersRow struct {
	CompanyID int64  `json:"company_id"`
	Name      string `json:"name"`
	Enabled   bool   `json:"enabled"`
}

func (q *Queries) Members(ctx context.Context, groupID int64) ([]MembersRow, error) {
	rows, err := q.db.Query(ctx, members, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MembersRow
	for rows.Next() {
		var i MembersRow
		if err := rows.Scan(&i.CompanyID, &i.Name, &i.Enabled); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertFxRate = `-- name: UpsertFxRate :exec
INSERT INTO fx_rates (as_of_date, pair, average_rate, closing_rate)
VALUES ($1, $2, $3, $4)
ON CONFLICT (as_of_date, pair)
DO UPDATE SET average_rate = EXCLUDED.average_rate, closing_rate = EXCLUDED.closing_rate
`

type UpsertFxRateParams struct {
	AsOfDate    pgtype.Date    `json:"as_of_date"`
	Pair        string         `json:"pair"`
	AverageRate pgtype.Numeric `json:"average_rate"`
	ClosingRate pgtype.Numeric `json:"closing_rate"`
}

func (q *Queries) UpsertFxRate(ctx context.Context, arg UpsertFxRateParams) error {
	_, err := q.db.Exec(ctx, upsertFxRate,
		arg.AsOfDate,
		arg.Pair,
		arg.AverageRate,
		arg.ClosingRate,
	)
	return err
}
